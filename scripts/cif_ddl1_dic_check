#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#* Check DDL1 dictionaries against a set of best practice rules.
#*
#* USAGE:
#*    $0 --options cif_core.dic
#**

use strict;
use warnings;
binmode STDOUT, ':encoding(UTF-8)';
binmode STDERR, ':encoding(UTF-8)';

use List::MoreUtils qw( any uniq );

use COD::CIF::Parser qw( parse_cif );
use COD::CIF::DDL::DDL1 qw( get_data_type );
use COD::SOptions qw( getOptions );
use COD::SUsage qw( usage options );
use COD::ErrorHandler qw( process_parser_messages );
use COD::ToolsVersion;

my $use_parser = 'c';
#* OPTIONS:
#*
#*   --help, --usage
#*                     Output a short usage message (this message) and exit.
#*   --version
#*                     Output version information and exit.
#**
@ARGV = getOptions(
    '--options'         => sub{ options; exit },
    '--help,--usage'    => sub{ usage; exit },
    '--version'      => sub { print 'cod-tools version ',
                                 $COD::ToolsVersion::Version, "\n";
                                 exit }
);

my $die_on_error_level = {
    'ERROR'   => 1,
    'WARNING' => 0,
    'NOTE'    => 0
};

for my $filename ( @ARGV ) {
    my $options = { 'parser' => $use_parser, 'no_print' => 1 };
    my ( $data, $err_count, $messages ) = parse_cif( $filename, $options );
    process_parser_messages( $messages, $die_on_error_level );

    for ( @{ check_metadata_block_presence( $data ) } ) {
        print "$0: $filename: $_.\n";
    }

    my $metadata_block_count = 0;
    for my $data_block ( @{$data} ) {
        for ( @{ check_dictionary_block( $data_block ) } ) {
            print "$0: $filename $data_block->{'name'}: $_.\n";
        }
    }
}

sub check_dictionary_block
{
    my ( $data_block ) = @_;

    if ( is_metadata_block( $data_block ) ) {
        return check_metadata_block( $data_block );
    }

    my @notes;
    if ( is_category_block( $data_block ) ) {
        push @notes, @{check_category_block( $data_block )};
    } else {
        push @notes, @{check_item_block( $data_block )};
    }

    return \@notes;
}

sub is_metadata_block
{
    my ( $data_block ) = @_;

    return ( lc $data_block->{'name'} eq 'on_this_dictionary' ) 
}

##
# Evaluates if a given data definition block defines a category.
#
# A proper category definition should have 'null' as the data type,
# 'category_overview' as the parent category and fit the category
# naming convention.
#
# @source https://www.iucr.org/resources/cif/dictionaries/cif_core/diffs2.0-1.0
#
# @param $data_block
#       Reference to a dictionary definition data block returned by
#       the COD::CIF::Parser.
# @return
#        1 if the definition defines a category,
#        0 otherwise.
##
sub is_category_block
{
    my ( $data_block ) = @_;

    # category definition should have the 'null' data type
    my $type = get_data_type( $data_block );
    if ( defined $type ) {
        return $type eq 'null' ? 1 : 0;
    }

    # category definition should have the 'category_overview' parent category
    my $category_name = get_category_name( $data_block );
    if ( defined $category_name ) {
        return $category_name eq 'category_overview' ? 1 : 0;
    }

    # category name should fit the naming convention
    my $name = get_data_name( $data_block );
    if ( defined $name ) {
        return is_proper_category_name($name) ? 1 : 0;
    }

    return 0;
}

##
# Evaluates if the data name adheres to the category naming convention.
#
# @source https://www.iucr.org/resources/cif/dictionaries/cif_core/diffs2.0-1.0
#
# @param $data_name
#       Name of the category.
# @return
#       1 is the data name is a proper category name,
#       0 otherwise
##
sub is_proper_category_name
{
    my ( $data_name ) = @_;

    return $data_name =~ m/_\[[^\]]*\]$/;
}

sub check_metadata_block_presence
{
    my ( $data ) = @_;

    my @metadata_blocks = grep { is_metadata_block( $_ ) } @{$data};

    my @notes;
    if ( !@metadata_blocks ) {
        push @notes,
             'dictionary metadata data block could not be located -- ' .
             "the data block is conventionally assigned the 'on_this_dictionary' " .
             'block code';
        return \@notes;
    }

    if ( @metadata_blocks > 1 ) {
        push @notes,
             'more than one dictionary metadata data block located -- ' .
             ( scalar @metadata_blocks ) . ' data blocks are assigned the ' .
             "'on_this_dictionary' block code"; 
        return \@notes;
    }

    return \@notes;
}

sub check_metadata_block
{
    my ( $data_block ) = @_;

    my @notes;
    # name and version allows to uniquely identify the dictionary
    my @mandatory_metadata_items = qw( _dictionary_name _dictionary_version );
    for my $data_name ( @mandatory_metadata_items ) {
        if ( !exists $data_block->{'values'}{$data_name} ) {
            push @notes,
                 "missing mandatory data item -- metadata item '$data_name' " .
                 'must be provided in the metadata data block';
        }
    }

    my @recommended_metadata_items = qw( _dictionary_update _dictionary_history );
    for my $data_name ( @recommended_metadata_items ) {
        if ( !exists $data_block->{'values'}{$data_name} ) {
            push @notes,
                 "missing recommended metadata item -- data item '$data_name' " .
                 'should be provided in the metadata data block';
        }
    }

    my @all_metadata_items = ( @mandatory_metadata_items,
                               @recommended_metadata_items );
    for my $data_name ( @{$data_block->{'tags'}} ) {
        if (! any { $_ eq $data_name } @all_metadata_items ) {
            push @notes,
                "data item '$data_name' should not appear in the metadata " .
                'data block'
        }
    }

    return \@notes;
}

##
# Checks if the category definition meets the IUCr category definition
# convention. 
#
# @source https://www.iucr.org/resources/cif/dictionaries/cif_core/diffs2.0-1.0
#
# @param $data_block
#       Reference to a dictionary definition data block returned by
#       the COD::CIF::Parser.
# @return
#       Array reference to a list of validation messages.
## 
sub check_category_block
{
    my ( $data_block ) = @_;

    my @notes;

    my $type = get_data_type( $data_block );
    if ( !defined $type ) {
        push @notes,
            "improper category definition -- the 'null' data type should " .
            "be explicitly specified using the '_type' data item";
    }

    my $category_name = get_category_name( $data_block );
    if ( !defined $category_name ) {
        push @notes,
            "improper category definition -- the 'category_overview' " .
            'parent category should be explicitly specified using ' .
            "the '_category' data item";
    } elsif ( $category_name ne 'category_overview' ) { 
        push @notes,
            "improper category definition -- data item '_category' value " .
            "'$category_name' should be set to 'category_overview'";
    }
    
    my $data_name = get_data_name( $data_block );
    if ( defined $data_name && !is_proper_category_name( $data_name ) ) {
        push @notes,
            "improper category definition -- data item '_name' value " .
            "'$data_name' should end with an underscore and a pair of " .
            'square brackets that may optionally enclose a code for the ' .
            "relevant dictionary extension, e.g. '_[]', '_[pd]'";
    }

    my @mandatory_items = qw( _name );
    for my $data_name ( @mandatory_items ) {
        if ( !exists $data_block->{'values'}{$data_name} ) {
            push @notes,
                "missing mandatory data item -- data item '$data_name' ".
                'must be provided in a category definition data block';
        }
    }

    my @recommended_items = qw( _definition );
    for my $data_name ( @recommended_items ) {
        if ( !exists $data_block->{'values'}{$data_name} ) {
            push @notes,
                "missing recommended data item -- data item '$data_name' ".
                'should be provided in a category definition data block';
        }
    }

    my @category_items = ( @mandatory_items,
                           @recommended_items,
                           '_category',
                           '_type',
                           '_example',
                           '_example_detail' );

    for my $data_name ( @{$data_block->{'tags'}} ) {
        if (! any { $_ eq $data_name } @category_items ) {
            push @notes,
                "data item '$data_name' should not appear in a category " .
                "definition data block"
        }
    }

    return \@notes;
}

sub check_item_block
{
    my ( $data_block ) = @_;

    my @notes;
    my @mandatory_items = qw( _name _type _category );
    for my $data_name ( @mandatory_items ) {
        if ( !exists $data_block->{'values'}{$data_name} ) {
            push @notes,
                "missing mandatory data item -- data item '$data_name' ".
                'must be provided in a data item definition data block';
        }
    }

    my @recommended_items = qw( _definition );
    for my $data_name ( @recommended_items ) {
        if ( !exists $data_block->{'values'}{$data_name} ) {
            push @notes,
                "missing recommended data item -- data item '$data_name' ".
                'should be provided in a data item definition data block';
        }
    }

    my @allowed_items = ( @mandatory_items, @recommended_items,
        qw(
            _enumeration
            _enumeration_default
            _enumeration_detail
            _enumeration_range
            _example
            _example_detail
            _list
            _list_level
            _list_link_child
            _list_link_parent
            _list_link_parent
            _list_mandatory
            _list_reference
            _list_uniqueness
            _related_function
            _related_item
            _type_conditions
            _type_construct
            _units
            _units_detail
        ) );

    for my $data_name ( @{$data_block->{'tags'}} ) {
        if (! any { $_ eq $data_name } @allowed_items ) {
            push @notes,
                "data item '$data_name' should not appear in a data item " .
                'definition data block'
        }
    }

    return \@notes;
}

##
# The following subroutines could be eventually moved to the 
# COD::CIF::DDL::DDL1 module
##

##
# Extracts the category name from a data item definition block.
# In case the definition block does not contain a category name
# an undef value is returned.
#
# @param $data_frame
#       Data item definition frame as returned by the COD::CIF::Parser.
# @return $data_name
#       String containing the category name or undef value if the data
#       block does not contain a definition id.
##
sub get_category_name
{
    my ( $dict_item ) = @_;

    return if !exists $dict_item->{'values'}{'_category'};

    return $dict_item->{'values'}{'_category'}[0];
}

sub get_data_name
{
    my ( $dict_item ) = @_;

    return if !exists $dict_item->{'values'}{'_name'};

    return $dict_item->{'values'}{'_name'}[0];
}
