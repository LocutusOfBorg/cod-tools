#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#* Check DDL1 dictionaries against a set of best practice rules.
#*
#* USAGE:
#*    $0 --options cif_core.dic
#**

use strict;
use warnings;
binmode STDOUT, ':encoding(UTF-8)';
binmode STDERR, ':encoding(UTF-8)';

use List::MoreUtils qw( any uniq );

use COD::CIF::Parser qw( parse_cif );
use COD::CIF::DDL::DDL1 qw( get_data_type );
use COD::SOptions qw( getOptions );
use COD::SUsage qw( usage options );
use COD::ErrorHandler qw( process_parser_messages );
use COD::ToolsVersion;

my $use_parser = 'c';
#* OPTIONS:
#*
#*   --help, --usage
#*                     Output a short usage message (this message) and exit.
#*   --version
#*                     Output version information and exit.
#**
@ARGV = getOptions(
    '--options'         => sub{ options; exit },
    '--help,--usage'    => sub{ usage; exit },
    '--version'      => sub { print 'cod-tools version ',
                                 $COD::ToolsVersion::Version, "\n";
                                 exit }
);

my $die_on_error_level = {
    'ERROR'   => 1,
    'WARNING' => 0,
    'NOTE'    => 0
};

for my $filename ( @ARGV ) {
    my $options = { 'parser' => $use_parser, 'no_print' => 1 };
    my ( $data, $err_count, $messages ) = parse_cif( $filename, $options );
    process_parser_messages( $messages, $die_on_error_level );

    for ( @{ check_metadata_block_presence( $data ) } ) {
        print "$0: $filename: $_.\n";
    }

    my $metadata_block_count = 0;
    for my $data_block ( @{$data} ) {
        for ( @{ check_dictionary_block( $data_block ) } ) {
            print "$0: $filename $data_block->{'name'}: $_.\n";
        }
    }
}

sub check_dictionary_block
{
    my ( $data_block ) = @_;

    if ( is_metadata_block( $data_block ) ) {
        return check_metadata_block( $data_block );
    }

    my @notes;
    if ( is_category_block( $data_block ) ) {
        push @notes, @{check_category_block( $data_block )};
    } else {
        push @notes, @{check_item_block( $data_block )};
    }

    return \@notes;
}

sub is_metadata_block
{
    my ( $data_block ) = @_;

    return ( lc $data_block->{'name'} eq 'on_this_dictionary' ) 
}

sub is_category_block
{
    my ( $data_block ) = @_;

    my $type = get_data_type( $data_block );
    return 0 if !defined $type;

    my $category = get_category( $data_block );
    return 0 if !defined $category;

    return ( $type eq 'null' &&  $category eq 'category_overview' );
}

sub check_metadata_block_presence
{
    my ( $data ) = @_;

    my @metadata_blocks = grep { is_metadata_block( $_ ) } @{$data};

    my @notes;
    if ( !@metadata_blocks ) {
        push @notes,
             'dictionary metadata data block could not be located -- ' .
             "the data block is conventionally assigned the 'on_this_dictionary' " .
             'block code';
        return \@notes;
    }

    if ( @metadata_blocks > 1 ) {
        push @notes,
             'more than one dictionary metadata data block located -- ' .
             ( scalar @metadata_blocks ) . ' data blocks are assigned the ' .
             "'on_this_dictionary' block code"; 
        return \@notes;
    }

    return \@notes;
}

sub check_metadata_block
{
    my ( $data_block ) = @_;

    my @notes;
    # name and version allows to uniquely identify the dictionary
    my @mandatory_metadata_items = qw( _dictionary_name _dictionary_version );
    for my $data_name ( @mandatory_metadata_items ) {
        if ( !exists $data_block->{'values'}{$data_name} ) {
            push @notes,
                 "missing mandatory data item -- metadata item '$data_name' " .
                 'must be provided in the metadata data block';
        }
    }

    my @recommended_metadata_items = qw( _dictionary_update _dictionary_history );
    for my $data_name ( @recommended_metadata_items ) {
        if ( !exists $data_block->{'values'}{$data_name} ) {
            push @notes,
                 "missing recommended metadata item -- data item '$data_name' " .
                 'should be provided in the metadata data block';
        }
    }

    my @all_metadata_items = ( @mandatory_metadata_items,
                               @recommended_metadata_items );
    for my $data_name ( @{$data_block->{'tags'}} ) {
        if (! any { $_ eq $data_name } @all_metadata_items ) {
            push @notes,
                "data item '$data_name' should not appear in the metadata " .
                'data block'
        }
    }

    return \@notes;
}

sub check_category_block
{
    my ( $data_block ) = @_;

    return [] if !is_category_block( $data_block );

    my @notes;
    my @mandatory_items = qw( _name _type _category );
    for my $data_name ( @mandatory_items ) {
        if ( !exists $data_block->{'values'}{$data_name} ) {
            push @notes,
                "missing mandatory data item -- data item '$data_name' ".
                'must be provided in a category definition data block';
        }
    }

    my @recommended_items = qw( _definition );
    for my $data_name ( @recommended_items ) {
        if ( !exists $data_block->{'values'}{$data_name} ) {
            push @notes,
                "missing recommended data item -- data item '$data_name' ".
                'should be provided in a category definition data block';
        }
    }

    my @category_items = ( @mandatory_items,
                           @recommended_items,
                           '_example',
                           '_example_detail' );

    for my $data_name ( @{$data_block->{'tags'}} ) {
        if (! any { $_ eq $data_name } @category_items ) {
            push @notes,
                "data item '$data_name' should not appear in a category " .
                "definition data block"
        }
    }

    return \@notes;
}

sub check_item_block
{
    my ( $data_block ) = @_;

    my @notes;
    my @mandatory_items = qw( _name _type _category );
    for my $data_name ( @mandatory_items ) {
        if ( !exists $data_block->{'values'}{$data_name} ) {
            push @notes,
                "missing mandatory data item -- data item '$data_name' ".
                'must be provided in a data item definition data block';
        }
    }

    my @recommended_items = qw( _definition );
    for my $data_name ( @recommended_items ) {
        if ( !exists $data_block->{'values'}{$data_name} ) {
            push @notes,
                "missing recommended data item -- data item '$data_name' ".
                'should be provided in a data item definition data block';
        }
    }

    my @allowed_items = ( @mandatory_items, @recommended_items,
        qw(
            _enumeration
            _enumeration_default
            _enumeration_detail
            _enumeration_range
            _example
            _example_detail
            _list
            _list_level
            _list_link_child
            _list_link_parent
            _list_link_parent
            _list_mandatory
            _list_reference
            _list_uniqueness
            _related_function
            _related_item
            _type_conditions
            _type_construct
            _units
            _units_detail
        ) );

    for my $data_name ( @{$data_block->{'tags'}} ) {
        if (! any { $_ eq $data_name } @allowed_items ) {
            push @notes,
                "data item '$data_name' should not appear in a data item " .
                "definition data block"
        }
    }

    return \@notes;
}

##
# The following subroutines could be eventually moved to the 
# COD::CIF::DDL::DDL1 module
##
sub get_category
{
    my ( $dict_item ) = @_;

    return if !exists $dict_item->{'values'}{'_category'};

    return $dict_item->{'values'}{'_category'}[0];
}
