#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#* Check DDL1 dictionaries against a set of best practice rules.
#*
#* USAGE:
#*    $0 --options cif_core.dic
#**

use strict;
use warnings;
binmode STDOUT, ':encoding(UTF-8)';
binmode STDERR, ':encoding(UTF-8)';

use List::MoreUtils qw( any uniq );

use COD::CIF::Parser qw( parse_cif );
use COD::CIF::DDL::DDL1 qw( get_data_type );
use COD::SOptions qw( getOptions get_value );
use COD::SUsage qw( usage options );
use COD::ErrorHandler qw( process_parser_messages );
use COD::ToolsVersion;

my $use_parser = 'c';
my @ref_dics;
#* OPTIONS:
#*   -d, --dictionaries 'cif_core.dic,cif_cod.dic'
#*                     A list of CIF dictionary files that conform to the DDL1.
#*                     Dictionaries in this list are only used to resolve
#*                     category and data item references provided in main
#*                     checked dictionary. List elements are separated
#*                     by the comma (',') symbol. In case the file path
#*                     of the included dictionary contains the comma symbol,
#*                     the --add-dictionary option should be used.
#*   -D, --add-dictionary 'additional DDL1 dictionary.dic'
#*                     Add an additional DDL1 dictionary to the list.
#*   --clear-dictionaries
#*                     Remove all DDL1 dictionaries from the list.
#*
#*   --help, --usage
#*                     Output a short usage message (this message) and exit.
#*   --version
#*                     Output version information and exit.
#**
@ARGV = getOptions(
    '-d,--dictionaries'    => sub{ @ref_dics = split m/,/, get_value() },
    '-D,--add-dictionary'  => sub { push @ref_dics, get_value() },
    '--clear-dictionaries' => sub { @ref_dics = () },

    '--options'         => sub{ options; exit },
    '--help,--usage'    => sub{ usage; exit },
    '--version'         => sub { print 'cod-tools version ',
                                 $COD::ToolsVersion::Version, "\n";
                                 exit }
);

my $die_on_error_level = {
    'ERROR'   => 1,
    'WARNING' => 0,
    'NOTE'    => 0
};

my $parser_options = { 'parser' => $use_parser, 'no_print' => 1 };
my %reference_dics;
for my $ref_dic_path ( @ref_dics ) {
    my ( $data, $err_count, $messages ) = parse_cif( $ref_dic_path, $parser_options );
    process_parser_messages( $messages, $die_on_error_level );
    $reference_dics{$ref_dic_path} = build_dic_struct( $data );
}

for my $filename ( @ARGV ) {
    my ( $data, $err_count, $messages ) = parse_cif( $filename, $parser_options );
    process_parser_messages( $messages, $die_on_error_level );

    my $dic = build_dic_struct( $data );
    for ( @{ check_metadata_block_multiplicity( $dic ) } ) {
        print "$0: $filename: $_.\n";
    }

    for my $data_block ( @{ get_dictionary_blocks( $dic ) } ) {
        for ( @{ check_metadata_block( $data_block ) } ) {
            print "$0: $filename $data_block->{'name'}: $_.\n";
        }
    }

    for my $data_block ( @{ get_category_blocks( $dic ) } ) {
        my @notes;
        push @notes, @{ check_category_block( $data_block ) };
        push @notes, @{ check_category_population( $data_block, get_item_blocks( $dic ) ) };
        for ( @notes ) {
            print "$0: $filename $data_block->{'name'}: $_.\n";
        }
    }

    for my $data_block ( @{ get_item_blocks( $dic ) } ) {
        my @notes;
        push @notes, @{ check_item_block( $data_block ) };
        push @notes, @{ check_list_link_parent(
                            $data_block,
                            $dic,
                            \%reference_dics
                        ) };
        push @notes, @{ check_list_link_child( $data_block, $dic ) };
        push @notes, @{ check_category_references( $data_block, $dic, \%reference_dics ) };
        for ( @notes ) {
            print "$0: $filename $data_block->{'name'}: $_.\n";
        }
    }
}

##
# Checks the validity of child data item references.
#
# @param $data_item
#       Reference to an item definition data block as returned by
#       the COD::CIF::Parser.
# @param $dic
#       DDL1 dictionary that contains the definition of the checked data item.
#       Passed as a reference to a data structure returned by the
#       build_dic_struct() subroutine.
# @return
#       Array reference to a list of validation messages.
##
sub check_list_link_child
{
    my ( $data_item, $dic ) = @_;

    return [] if !exists $data_item->{'values'}{'_list_link_child'};
    my $child_item_names = $data_item->{'values'}{'_list_link_child'};

    my @notes;
    for my $child_item_name ( @{$child_item_names} ) {
        my $child_block = get_item_block_by_name( $dic, $child_item_name );
        if ( defined $child_block ) {
            my $child_type  = get_data_type( $child_block );
            my $parent_type = get_data_type( $data_item );
            if ( defined $child_type && defined $parent_type &&
                 $child_type ne $parent_type ) {
                push @notes,
                     "data types of the given data item and the referenced ".
                     "child data item '$child_item_name' do not match " .
                     "('$parent_type' vs. '$child_type')";
            }
        } else {
            push @notes,
                 "definition of the child data item '$child_item_name' " .
                 'could not be located';
         }
    }

    return \@notes;
}

##
# Checks the validity of parent data item references.
#
# @param $data_item
#       Reference to an item definition data block as returned by
#       the COD::CIF::Parser.
# @param $dic
#       DDL1 dictionary that contains the definition of the checked data item.
#       Passed as a reference to a data structure returned by the
#       build_dic_struct() subroutine.
# @param $extra_dics
#       A set of DDL1 dictionaries that are additionally checked in case
#       the parent data item definition cannot be located in the $dic
#       dictionary. Passed as a reference to a hash of data structures
#       returned by the build_dic_struct() subroutine.
# @return
#       Array reference to a list of validation messages.
##
sub check_list_link_parent
{
    my ( $data_item, $dic, $extra_dics ) = @_;
    return [] if !exists $data_item->{'values'}{'_list_link_parent'};

    my $parent_item_name = $data_item->{'values'}{'_list_link_parent'}[0];

    my $parent_block = get_item_block_by_name( $dic, $parent_item_name );

    for my $key ( keys %{$extra_dics} ) {
        last if defined $parent_block;
        my $extra_dic = $extra_dics->{$key};
        $parent_block = get_item_block_by_name( $extra_dic, $parent_item_name );
    }

    my @notes;
    if ( defined $parent_block ) {
        my $child_type  = get_data_type( $data_item );
        my $parent_type = get_data_type( $parent_block );
        if ( defined $child_type && defined $parent_type &&
             $child_type ne $parent_type ) {

            push @notes,
                 "data types of the given data item and the referenced".
                 " parent data item '$parent_item_name' do not match " .
                 "('$child_type' vs. '$parent_type')";
        }
    } else {
        push @notes,
             "definition of the referenced parent data item " .
             "'$parent_item_name' could not be located";
    }

    return \@notes;
}

sub check_category_population
{
    my ( $category_block, $data_items ) = @_;

    my $data_name = get_data_name( $category_block );
    return [] if !defined $data_name;

    $data_name = make_ref_category_name( $data_name );
    my $has_related_items = 0;
    for my $data_item ( @{$data_items} ) {
        my $category_name = get_category_name( $data_item );
        next if !defined $category_name;
        if ( $data_name eq $category_name ) {
            $has_related_items = 1;
            last;
        }
    }

    my @notes;
    if ( !$has_related_items ) {
        push @notes,
             "category '$data_name' does not have any related " .
             "data item definitions";
    }

    return \@notes;
}

sub check_category_references
{
    my ( $data_block, $dic, $extra_dics ) = @_;

    my $category_name = get_category_name( $data_block );
    return [] if !defined $category_name;

    #~ return [] if exists $categories->{$category_name};

    #~ my $category_found = 0;
    #~ for my $key ( keys %{$extra_dics} ) {
        #~ last if $category_found;
        #~ my $ref_dic = $extra_dics->{$key};
        #~ for my $category ( @{ $ref_dic->{'category'} } ) {
            #~ my $data_names = get_data_names( $category );
            #~ next if !defined $data_names;
            #~ @{$data_names} = map { make_ref_category_name($_) } @{$data_names};
            #~ if ( any { $_ eq $category_name } @{$data_names} ) {
                #~ $category_found = 1;
                #~ last;
            #~ }
        #~ }
    #~ }

    #~ my @notes;
    #~ if ( !$category_found ) {
        #~ push @notes,
             #~ "definition of the parent category '$category_name' could " .
             #~ 'not be located';
    #~ }

    my @notes;
    if ( !defined get_category_block_by_ref_name( $dic, $category_name ) ) {
        push @notes,
             "definition of the parent category '$category_name' could " .
             'not be located';
    }

    return \@notes;
}

##
# Evaluates if a given data definition block defines a category.
#
# A proper category definition should have 'null' as the data type,
# 'category_overview' as the parent category and fit the category
# naming convention.
#
# @source https://www.iucr.org/resources/cif/dictionaries/cif_core/diffs2.0-1.0
#
# @param $data_block
#       Reference to a category definition data block returned by
#       the COD::CIF::Parser.
# @return
#        1 if the definition defines a category,
#        0 otherwise.
##
sub is_category_block
{
    my ( $data_block ) = @_;

    # category definition should have the 'null' data type
    my $type = get_data_type( $data_block );
    if ( defined $type ) {
        return $type eq 'null' ? 1 : 0;
    }

    # category definition should have the 'category_overview' parent category
    my $category_name = get_category_name( $data_block );
    if ( defined $category_name ) {
        return $category_name eq 'category_overview' ? 1 : 0;
    }

    # category name should fit the naming convention
    my $name = get_data_name( $data_block );
    if ( defined $name ) {
        return is_proper_category_name( $name ) ? 1 : 0;
    }

    return 0;
}

##
# Evaluates if the data name adheres to the category naming convention.
#
# @source https://www.iucr.org/resources/cif/dictionaries/cif_core/diffs2.0-1.0
#
# @param $data_name
#       Name of the category.
# @return
#       1 is the data name is a proper category name,
#       0 otherwise
##
sub is_proper_category_name
{
    my ( $data_name ) = @_;

    return $data_name =~ m/_\[[^\]]*\]$/;
}

sub check_metadata_block_multiplicity
{
    my ( $dic ) = @_;

    my $metadata_blocks = get_dictionary_blocks( $dic );
    my @notes;
    if ( !@{$metadata_blocks} ) {
        push @notes,
             'dictionary metadata data block could not be located -- ' .
             "the data block is conventionally assigned the 'on_this_dictionary' " .
             'block code';
        return \@notes;
    }

    if ( @{$metadata_blocks} > 1 ) {
        push @notes,
             'more than one dictionary metadata data block located -- ' .
             ( scalar @{$metadata_blocks} ) . ' data blocks are assigned the ' .
             "'on_this_dictionary' block code";
        return \@notes;
    }

    return \@notes;
}

sub check_metadata_block
{
    my ( $data_block ) = @_;

    my @notes;
    # name and version allows to uniquely identify the dictionary
    my @mandatory_metadata_items = qw( _dictionary_name _dictionary_version );
    for my $data_name ( @mandatory_metadata_items ) {
        if ( !exists $data_block->{'values'}{$data_name} ) {
            push @notes,
                 "missing mandatory data item -- metadata item '$data_name' " .
                 'must be provided in the metadata data block';
        }
    }

    my @recommended_metadata_items = qw( _dictionary_update _dictionary_history );
    for my $data_name ( @recommended_metadata_items ) {
        if ( !exists $data_block->{'values'}{$data_name} ) {
            push @notes,
                 "missing recommended metadata item -- data item '$data_name' " .
                 'should be provided in the metadata data block';
        }
    }

    my @all_metadata_items = ( @mandatory_metadata_items,
                               @recommended_metadata_items );
    for my $data_name ( @{$data_block->{'tags'}} ) {
        if (! any { $_ eq $data_name } @all_metadata_items ) {
            push @notes,
                "data item '$data_name' should not appear in the metadata " .
                'data block'
        }
    }

    return \@notes;
}

##
# Checks if the category definition meets the IUCr category definition
# convention.
#
# @source https://www.iucr.org/resources/cif/dictionaries/cif_core/diffs2.0-1.0
#
# @param $data_block
#       Reference to a dictionary definition data block returned by
#       the COD::CIF::Parser.
# @return
#       Array reference to a list of validation messages.
##
sub check_category_block
{
    my ( $data_block ) = @_;

    my @notes;

    my $type = get_data_type( $data_block );
    if ( !defined $type ) {
        push @notes,
            "improper category definition -- the 'null' data type should " .
            "be explicitly specified using the '_type' data item";
    }

    my $category_name = get_category_name( $data_block );
    if ( !defined $category_name ) {
        push @notes,
            "improper category definition -- the 'category_overview' " .
            'parent category should be explicitly specified using ' .
            "the '_category' data item";
    } elsif ( $category_name ne 'category_overview' ) {
        push @notes,
            "improper category definition -- data item '_category' value " .
            "'$category_name' should be set to 'category_overview'";
    }

    my $data_name = get_data_name( $data_block );
    if ( defined $data_name ) {
        if ( !is_proper_category_name( $data_name ) ) {
            push @notes,
                "improper category definition -- data item '_name' value " .
                "'$data_name' should end with an underscore and a pair of " .
                'square brackets that may optionally enclose a code for the ' .
                "relevant dictionary extension, e.g. '_[]', '_[pd]'";
        }

        my $block_code = $data_block->{'name'};
        if ( $data_name ne '_' . $block_code ) {
            push @notes,
                 "category definition block code '$block_code' is not " .
                 "compatible with the provided data name '$data_name' -- " .
                 'the block code should be derived from the data name by ' .
                 "removing the leading underscore ('_') symbol";
        }
    }

    my @mandatory_items = qw( _name );
    for my $data_name ( @mandatory_items ) {
        if ( !exists $data_block->{'values'}{$data_name} ) {
            push @notes,
                "missing mandatory data item -- data item '$data_name' ".
                'must be provided in a category definition data block';
        }
    }

    my @recommended_items = qw( _definition );
    for my $data_name ( @recommended_items ) {
        if ( !exists $data_block->{'values'}{$data_name} ) {
            push @notes,
                "missing recommended data item -- data item '$data_name' ".
                'should be provided in a category definition data block';
        }
    }

    my @category_items = ( @mandatory_items,
                           @recommended_items,
                           '_category',
                           '_type',
                           '_example',
                           '_example_detail' );

    for my $data_name ( @{$data_block->{'tags'}} ) {
        if (! any { $_ eq $data_name } @category_items ) {
            push @notes,
                "data item '$data_name' should not appear in a category " .
                "definition data block"
        }
    }

    return \@notes;
}

sub check_item_block
{
    my ( $data_block ) = @_;

    my @notes;
    my @mandatory_items = qw( _name _type _category );
    for my $data_name ( @mandatory_items ) {
        if ( !exists $data_block->{'values'}{$data_name} ) {
            push @notes,
                "missing mandatory data item -- data item '$data_name' ".
                'must be provided in a data item definition data block';
        }
    }

    my @recommended_items = qw( _definition );
    for my $data_name ( @recommended_items ) {
        if ( !exists $data_block->{'values'}{$data_name} ) {
            push @notes,
                "missing recommended data item -- data item '$data_name' ".
                'should be provided in a data item definition data block';
        }
    }

    my @allowed_items = ( @mandatory_items, @recommended_items,
        qw(
            _enumeration
            _enumeration_default
            _enumeration_detail
            _enumeration_range
            _example
            _example_detail
            _list
            _list_level
            _list_link_child
            _list_link_parent
            _list_link_parent
            _list_mandatory
            _list_reference
            _list_uniqueness
            _related_function
            _related_item
            _type_conditions
            _type_construct
            _units
            _units_detail
        ) );

    for my $data_name ( @{$data_block->{'tags'}} ) {
        if (! any { $_ eq $data_name } @allowed_items ) {
            push @notes,
                "data item '$data_name' should not appear in a data item " .
                'definition data block'
        }
    }

    return \@notes;
}

##
# Subroutines relating to the DDL1 data structure.
##
sub classify_dic_blocks
{
    my ( $dic ) = @_;

    my %dic_blocks;
    my @metadata;
    my @category;
    my @item;
    for my $data_block ( @{$dic} ) {
        if ( is_metadata_block( $data_block ) ) {
            push @metadata, $data_block;
        } elsif ( is_category_block( $data_block ) ) {
            push @category, $data_block;
        } else {
            push @item, $data_block;
        }
    }

    $dic_blocks{'dictionary'} = \@metadata;
    $dic_blocks{'category'}   = \@category;
    $dic_blocks{'item'}       = \@item;

    return \%dic_blocks;
}

sub build_dic_struct
{
    my ( $data ) = @_;

    my $classified_blocks = classify_dic_blocks($data);

    my %dic_struct = (
        'item'       => [],
        'category'   => [],
        'dictionary' => [],
        'search' => {
            'item' => {
                'by_block_code' => {},
                'by_data_name'  => {},
            },
            'category' => {
                'by_block_code' => {},
                'by_data_name'  => {},
                'by_ref_name'   => {},
            },
        }
    ); 

    $dic_struct{'dictionary'} = $classified_blocks->{'dictionary'};

    $dic_struct{'category'} = $classified_blocks->{'category'};
    for my $category_block ( @{$dic_struct{'category'}} ) {
        my $search_struct = $dic_struct{'search'}{'category'};

        my $block_code = $category_block->{'name'};
        $search_struct->{'by_block_code'}{$block_code} = $category_block;

        my $data_name = get_data_name( $category_block );
        next if !defined $data_name;
        $search_struct->{'by_data_name'}{$data_name} = $category_block;
        my $ref_name = make_ref_category_name( $data_name );
        $search_struct->{'by_ref_name'}{$ref_name} = $category_block;
    }

    $dic_struct{'item'} = $classified_blocks->{'item'};
    for my $item_block ( @{$dic_struct{'item'}} ) {
        my $search_struct = $dic_struct{'search'}{'item'};

        my $block_code = $item_block->{'name'};
        $search_struct->{'by_block_code'}{$block_code} = $item_block;

        my $data_names = get_data_names( $item_block );
        next if !defined $data_names;
        for my $data_name ( @{$data_names} ) {
            $search_struct->{'by_data_name'}{$data_name} = $item_block;
        }
    }

    return \%dic_struct;
}

sub get_item_blocks
{
    my ( $dic ) = @_;

    return $dic->{'item'};
}

sub get_item_block_by_name
{
    my ( $dic, $data_name ) = @_;

    if ( exists $dic->{'search'}{'item'}{'by_data_name'}{$data_name} ) {
        return $dic->{'search'}{'item'}{'by_data_name'}{$data_name};
    }

    return;
}

sub get_category_blocks
{
    my ( $dic ) = @_;

    return $dic->{'category'};
}

sub get_category_block_by_data_name
{
    my ( $dic, $data_name ) = @_;

    if ( exists $dic->{'search'}{'category'}{'by_data_name'}{$data_name} ) {
        return $dic->{'search'}{'category'}{'by_data_name'}{$data_name};
    }

    return;
}

sub get_category_block_by_ref_name
{
    my ( $dic, $data_name ) = @_;

    if ( exists $dic->{'search'}{'category'}{'by_ref_name'}{$data_name} ) {
        return $dic->{'search'}{'category'}{'by_ref_name'}{$data_name};
    }

    return;
}

sub get_dictionary_blocks
{
    my ( $dic ) = @_;

    return $dic->{'dictionary'};
}

##
# The following subroutines could be eventually moved to the
# COD::CIF::DDL::DDL1 module
##
sub is_metadata_block
{
    my ( $data_block ) = @_;

    return ( lc $data_block->{'name'} eq 'on_this_dictionary' )
}

sub make_ref_category_name
{
    my ( $data_name ) = @_;

    my $referenced_name = $data_name;
    if ( $data_name =~ m/^_(.+)_\[[^\]]*\]$/ ) {
        $referenced_name = $1;
    }

    return $referenced_name;
}

##
# Extracts the category name from a data item definition block.
# In case the definition block does not contain a category name
# an undef value is returned.
#
# @param $data_frame
#       Data item definition frame as returned by the COD::CIF::Parser.
# @return $data_name
#       String containing the category name or undef value if the data
#       block does not contain a definition id.
##
sub get_category_name
{
    my ( $dict_item ) = @_;

    return if !exists $dict_item->{'values'}{'_category'};

    return $dict_item->{'values'}{'_category'}[0];
}

sub get_data_name
{
    my ( $dic_item ) = @_;

    my $data_names = get_data_names( $dic_item );
    return if !defined $data_names;

    return $data_names->[0];
}

sub get_data_names
{
    my ( $dict_item ) = @_;

    return if !exists $dict_item->{'values'}{'_name'};

    return $dict_item->{'values'}{'_name'};
}
