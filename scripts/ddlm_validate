#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#  Check dictionaries written in DDLm against the specified instance of
#  the DDLm dictionary.
#**

use strict;
use warnings;

use COD::CIF::Parser qw( parse_cif );
use COD::SOptions qw( getOptions get_value );
use COD::SUsage qw( usage options );
use COD::ErrorHandler qw( process_warnings
                          process_parser_messages
                          report_message );
use File::Basename;

my $use_parser = 'c';
my $ddlm_dictionary;

my $die_on_errors   = 1;
my $die_on_warnings = 0;
my $die_on_notes    = 0;

@ARGV = getOptions(
    '-d,--DDLm-dictionary' => sub { $ddlm_dictionary = get_value() },
    '--options'         => sub{ options; exit },
    '--help,--usage'    => sub{ usage; exit; },

    '--continue-on-errors'          => sub { $die_on_errors = 0 },
    '--die-on-errors'               => sub { $die_on_errors = 1 },

    '--continue-on-warnings' => sub { $die_on_warnings = 0 },
    '--die-on-warnings'      => sub { $die_on_warnings = 1 },

    '--continue-on-notes'    => sub { $die_on_notes = 0 },
    '--die-on-notes'         => sub { $die_on_notes = 1 },
);

my $die_on_error_level = {
    ERROR   => $die_on_errors,
    WARNING => $die_on_warnings,
    NOTE    => $die_on_notes
};

my $options = { 'parser' => $use_parser, 'no_print' => 1 };
my ( $data, $err_count, $messages ) = parse_cif( $ddlm_dictionary, $options );
# TODO: warn if there are more than 1 datablock in a file
process_parser_messages( $messages, $die_on_error_level );

my $dict_block = $data->[0];

my($filename, $dirs, $suffix) = fileparse($ddlm_dictionary);

my $imported_data = get_imported_files(
    {
        'container_file' => $dict_block,
        # TODO: the path should also be cosntructed from the command line
        # arguments as well as a command line variable
        'file_path'      => [ "./", $dirs ],
        'imported_files' => {},
        'parser_options' => $options
    }
);

$dict_block = merge_imported_files( $dict_block, $imported_data );

my $validation_dict = build_dictionary($dict_block);

@ARGV = ('-') unless @ARGV;
# start-iterate-through-CIF-files
for my $filename ( @ARGV ) {
    my $options = { 'parser' => $use_parser, 'no_print' => 1 };
    my ( $data, $err_count, $messages ) = parse_cif( $filename, $options );
    process_parser_messages( $messages, $die_on_error_level );

    # TODO: complain if there if more than one data block
    for my $datablock ( @{$data} ) {
      my $dataname = 'data_' . $datablock->{'name'} if defined $datablock->{'name'};
      local $SIG{__WARN__} = sub { process_warnings( {
                                     'message'       => @_,
                                     'program'       => $0,
                                     'filename'      => $filename,
                                     'add_pos'       => $dataname
                                   }, $die_on_error_level ) };

        my $imported_data = get_imported_files(
            {
            'container_file' => $datablock,
            # TODO: the path should also be cosntructed from the command line
            # arguments as well as a command line variable
            'file_path'      => [ "./", $dirs ],
            'imported_files' => {},
            'parser_options' => $options
            }
        );

      $datablock = merge_imported_files( $datablock, $imported_data );

      my $dict = build_dictionary($datablock);

      # TODO: the validation strucutre should be constructed only once
      # instead of passing it repeateadly for each file
      if ( exists $validation_dict->{'Datablock'}
                  {'values'}{'_dictionary_valid.application'} ) {
        validate_scope_restrictions($dict, $validation_dict);
      }

      validate_enumerators($dict, $validation_dict);
    }
}

sub validate_enumerators
{
    my ($dict, $validation_dict) = @_;

    for my $scope ( 'Dictionary', 'Category', 'Item' ) {
      for my $instance ( keys %{$dict->{$scope}} ) {
        for my $tag ( @{$dict->{$scope}{$instance}{'tags'}} ) {
          if ( exists $validation_dict->{'Item'}{$tag} ) {
            my $validation_item = $validation_dict->{'Item'}{$tag};
            if ( exists $validation_item->{'values'}{'_enumeration_set.state'} ) {
                my @enumeration_values = @{
                                $validation_item->{'values'}
                                {'_enumeration_set.state'} };
                # TODO: in some cases hard coding default values is inevitable
                # so it might make sense to store them in a single place with
                # the version number that corresponds to the specific version
                # number of the DDL?
                my $type_container = 'Single';
                if ( exists $validation_item->{'values'}{'_type.container'}) {
                    $type_container = $validation_item->{'values'}{'_type.container'}[0];
                }

                my $value = $dict->{$scope}{$instance}{'values'}{$tag}[0];
                if ( lc $type_container eq lc 'Single' ) {
                    if (! grep { lc $value eq lc $_ } @enumeration_values ) {
                    #  print "$instance: $tag: $value is not permitted\n";
                    warn "data item '$tag' value \"$value\" "
                         . 'must be one of the enumeration values '
                         . '[' . ( join ', ', @enumeration_values ) . ']';
                    }
                # TODO: consider all of these combinations?
                } elsif ( lc $type_container eq lc 'Array' ) {

                } elsif ( lc $type_container eq lc 'Matrix') {

                } elsif ( lc $type_container eq lc 'List' ) {

                } elsif ( lc $type_container eq lc 'Table' ) {

                } elsif ( lc $type_container eq lc 'Multiple' ) {
                    if (! grep { lc $value eq lc $_ } @enumeration_values ) {
                    #  print "$instance: $tag: $value is not permitted\n";
                    warn "data item '$tag' value \"$value\" "
                       . 'must be one of the enumeration values '
                       . '[' . ( join ', ', @enumeration_values ) . ']. '
                       . 'This message might be a false positive since '
                       . 'handling of enumeration values with the ' 
                       . "'Multiple' type container is not yet implemented\n";
                    }
                }
            }
          }
        }
      }
    }
}

# TODO: maybe this subroutine should return an array of error messages?
# instead of printing directly to STDERR?
sub validate_scope_restrictions
{
    my ($dict, $validation_dict) = @_;

      my %dict_restrictions;
      my $valid_application = $validation_dict->{'Datablock'}
                              {'values'}{'_dictionary_valid.application'};
      my $valid_attributes  = $validation_dict->{'Datablock'}
                              {'values'}{'_dictionary_valid.attributes'};
      for (my $i = 0; $i < @{$valid_application}; $i++) {
          $dict_restrictions
            {$valid_application->[$i][0]}
            {$valid_application->[$i][1]} = $valid_attributes->[$i]
      };
      # expand valid attribute categories into individual data item names
      foreach my $scope (keys %dict_restrictions) {
        foreach my $option ( keys %{$dict_restrictions{$scope}} ) {
            $dict_restrictions{$scope}{$option} =
                expand_categories($dict_restrictions{$scope}{$option},
                                  $validation_dict);
        }
      }

      for my $scope ( 'Dictionary', 'Category', 'Item' ) {
        for my $instance ( keys %{$dict->{$scope}} ) {
          my %mandatory   = map { $_ => 0 } @{$dict_restrictions{$scope}{'Mandatory'}};
          my %recommended = map { $_ => 0 } @{$dict_restrictions{$scope}{'Recommended'}};
          my %prohibited  = map { $_ => 0 } @{$dict_restrictions{$scope}{'Prohibited'}};
          for my $tag ( @{$dict->{$scope}{$instance}{'tags'}} ) {
              if ( exists $prohibited{$tag} ) {
                warn "data item '$tag' is prohibited in the '$scope' scope of " .
                     "the $instance frame\n";
              }
              $mandatory{$tag}   = 1 if ( exists $mandatory{$tag} );
              $recommended{$tag} = 1 if ( exists $recommended{$tag} );
          }
          foreach my $tag (keys %mandatory) {
            if ( $mandatory{$tag} == 0 ) {
                warn "data item '$tag' is mandatory in the '$scope' scope of " .
                     "the $instance frame\n"
            }
          }
          foreach my $tag (keys %recommended) {
            if ( $recommended{$tag} == 0 ) {
        #        warn "data item '$tag' is recommended in the '$scope' scope of " .
        #             "the $instance frame\n"
            }
          }
        }
      }

    return;
}

sub build_dictionary
{
    my ($data) = @_;

    my %categories;
    my %items;
    for my $saveblock ( @{$data->{'save_blocks'}} ) {
        my $values = $saveblock->{values};

        if ( exists $values->{'_definition.scope'} ) {
            if ( $values->{'_definition.scope'}[0] eq 'Dictionary' ) {
                next; #
            } elsif ( $values->{'_definition.scope'}[0] eq 'Category' ) {
                $categories{ $values->{'_definition.id'}[0] } = $saveblock;
            } elsif ( $values->{'_definition.scope'}[0] eq 'Item' ) {
                $items{ $values->{'_definition.id'}[0] } = $saveblock;
            } else {
                # this error should be reported by the enumeration check
            }
        } else {
            # ITEM is currently stated as the default value
            $items{ $values->{'_definition.id'}[0] } = $saveblock;
        }
    };

    my $dictionary = {
        'Dictionary' => { $data->{'name'} => $data },
        'Category'   => \%categories,
        'Item'       => \%items,
        'Datablock'  => $data
    };

    return $dictionary;
}

#
# dictionary = {
#   'file_path'       => [ 'dir1', 'dir2', 'dir3' ]
#   'container_file' =>
#   'imported_files'  =>
#   'parser_options'  =>
# }
#
# TODO: consider a more conservative dictionary import system
#
sub get_imported_files
{
    my ($params) = @_;
    my $file_path = $params->{'file_path'};
    my $container_file = $params->{'container_file'};
    my %imported_files = %{$params->{'imported_files'}};
    my $parser_options = $params->{'parser_options'};

    for my $saveblock ( @{$container_file->{'save_blocks'}} ) {
      if ( exists $saveblock->{'values'}{'_import.get'} &&
           exists $saveblock->{'values'}{'_import.get'}[0] ) {
        foreach my $import ( @{$saveblock->{'values'}{'_import.get'}[0]} ) {
          my $filename = $import->{'file'};
          if ( !exists $imported_files{$filename} ) {
            foreach my $path ( @{$file_path} ) {
              # TODO: the path ends up with a double slash
              if ( -f "$path/$filename" ) {
                my ( $import_data, $err_count, $messages ) =
                  parse_cif( "$path/$filename", $parser_options );
                # TODO: check how the error messages interact with the
                # subroutine context
                process_parser_messages( $messages, $die_on_error_level );
                $imported_files{$filename} = $import_data->[0];
                my $single_import = get_imported_files( {
                    'file_path'      => $file_path,
                    'container_file' => $import_data->[0],
                    'imported_files' => \%imported_files,
                    'parser_options' => $parser_options
                } );
                %imported_files = %{$single_import};
                last;
              }
            }
          }
        }
      }
    }

    return \%imported_files;
}

# TODO: check for cyclic relationships
sub merge_imported_files
{
    my ($dict, $imported_files) = @_;

    for my $saveblock ( @{$dict->{'save_blocks'}} ) {
      if ( exists $saveblock->{'values'}{'_import.get'} &&
           exists $saveblock->{'values'}{'_import.get'}[0] ) {
        foreach my $import ( @{$saveblock->{'values'}{'_import.get'}[0]} ) {
          my $filename = $import->{'file'};
          if ( exists $imported_files->{$filename} ) {
            my $imported_file = $imported_files->{$filename};
            $imported_file = merge_imported_files($imported_file, $imported_files);


            my $target_saveblock = $import->{'save'};
            foreach my $imported_saveblock ( @{$imported_file->{'save_blocks'}} ) {
              # TODO: check for case-sensitivity
              if ( $imported_saveblock->{'name'} eq $target_saveblock ) {
                $saveblock = merge_save_blocks($saveblock, $imported_saveblock);
              }
            }
          }
        }
      }
    }

    return $dict;
}

# TODO: rewrite as non-destructive?
sub merge_save_blocks
{
    my ($main_save_block, $auxilary_save_block) = @_;

    foreach my $key ( keys %{$auxilary_save_block->{'types'}} ) {
        $main_save_block->{'types'}{$key} = $auxilary_save_block->{'types'}{$key};
    }

    foreach my $key ( keys %{$auxilary_save_block->{'values'}} ) {
        $main_save_block->{'values'}{$key} = $auxilary_save_block->{'values'}{$key};
    }

    foreach my $key ( keys %{$auxilary_save_block->{'inloop'}} ) {
        $main_save_block->{'inloop'}{$key} =
            $auxilary_save_block->{'inloop'}{$key} +
            scalar @{$main_save_block->{'loops'}};
    }

    push @{$main_save_block->{'loops'}}, @{$auxilary_save_block->{'loops'}};
    push @{$main_save_block->{'tags'}}, @{$auxilary_save_block->{'tags'}};

    return $main_save_block;
}

sub expand_categories
{
    my ($categories, $dict) = @_;

    my @expanded_categories;
    foreach my $category (@$categories) {
        if ( exists $dict->{'Item'}{$category} ) {
            push @expanded_categories, $category;
        } elsif ( exists $dict->{'Category'}{$category} ) {
            for my $id (keys %{$dict->{'Item'}}) {
                if ( exists $dict->{'Item'}{$id}{'values'}{'_name.category_id'} &&
                     lc $dict->{'Item'}{$id}{'values'}{'_name.category_id'}[0] eq lc $category ) {
                    push @expanded_categories, $id;
                }
            }
            for my $id (keys %{$dict->{'Category'}}) {
                if ( exists $dict->{'Category'}{$id}{'values'}{'_name.category_id'}[0] &&
                     lc $dict->{'Category'}{$id}{'values'}{'_name.category_id'}[0] eq lc $category ) {
                    push @expanded_categories, @{expand_categories([ $id ], $dict)};
                }
            }
        } else {
          #  print keys %{$dict->{'Item'}};
            print "$category\n";
            die "No such data item or category was found in dictionary";
        }
    }

    return \@expanded_categories;
}
