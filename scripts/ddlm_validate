#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#* Check dictionaries written in DDLm against the specified instance of
#* the DDLm dictionary.
#*
#* USAGE:
#*    $0 --dictionaries 'cif_core.dic,cif_cod.dic' --options input1.cif input*.cif
#**

use strict;
use warnings;
binmode STDOUT, ':encoding(UTF-8)';
binmode STDERR, ':encoding(UTF-8)';

use List::MoreUtils qw( any uniq );
use File::Basename;
use Scalar::Util qw( looks_like_number );
use URI::Split qw(uri_split);

use COD::CIF::Parser qw( parse_cif );
use COD::CIF::DDL::Ranges qw( parse_range
                              range_to_string
                              is_in_range );
use COD::CIF::DDL::DDLm qw( build_search_struct
                            get_data_alias
                            get_data_name
                            get_imported_files
                            merge_imported_files
                            get_type_contents
                            get_type_container
                            get_type_purpose
                            get_definition_class );
use COD::CIF::Tags::Manage qw( has_special_value has_numeric_value );
use COD::DateTime qw( parse_date parse_datetime canonicalise_timestamp );
use COD::Precision qw( unpack_cif_number );
use COD::SOptions qw( getOptions get_value );
use COD::SUsage qw( usage options );
use COD::ErrorHandler qw( process_warnings
                          process_parser_messages
                          report_message );
use COD::UserMessage qw( sprint_message );
use COD::ToolsVersion;

my $use_parser = 'c';
my $verbose = 0;
my $report_local_tags = 0;
my $report_deprecated = 0;
my $report_missing_su = 0;
my @dict_files;

my $die_on_errors   = 1;
my $die_on_warnings = 0;
my $die_on_notes    = 0;

#* OPTIONS:
#*   -d, --dictionaries 'cif_core.dic,cif_cod.dic'
#*                     A list of CIF dictionary files (according to DDLm)
#*                     to be used in CIF file validation. List elements
#*                     are separated either by ',' or by ' '. To include
#*                     dictionaries with filenames containing these symbols,
#*                     the --add-dictionary option is used.
#*   -D, --add-dictionary 'cif new dictionary.dic'
#*                     Add additional CIF dictionary to the list.
#*   --clear-dictionaries
#*                     Remove all CIF dictionaries from the list.
#*
#*   --verbose
#*                     Output additional validation messages describing
#*                     previously grouped validation errors in more detail.
#*   --no-verbose
#*                     Do not output additional validation messages describing
#*                     previously grouped validation errors in more detail
#*                     (default).
#*
#*   --report-deprecated
#*                     Report data items that are marked as deprecated in the
#*                     dictionaries. Data item deprecation usually means that
#*                     it has been replaced with an another data item.
#*   --ignore-deprecated
#*                     Do not report data items that are marked as deprecated
#*                     in the dictionaries (default).
#*
#*   --report-local-tags
#*                     Validate data items having tags prefixed with
#*                     the '_[local]' prefix.
#*   --no-report-local-tags, --ignore-local-tags
#*                     Ignore data items having tags prefixed with '_[local]'
#*                     prefix (default).
#*
#*  --report-missing-su
#*                     Report measurand data items that are not accompanied by
#*                     the mandatory standard uncertainty values.
#*  --no-report-missing-su, --ignore-missing-su
#*                     Do not report measurand data items that are not
#*                     accompanied by the mandatory standard uncertainty
#*                     values (default)
#*
#*   --continue-on-errors
#*                     Do not terminate script if errors are raised (default).
#*   --die-on-errors
#*                     Terminate script immediately if errors are raised.
#*   --continue-on-warnings
#*                     Do not terminate script if warnings are raised (default).
#*   --die-on-warnings
#*                     Terminate script immediately if warnings are raised.
#*   --continue-on-notes
#*                     Do not terminate script if notes are raised (default).
#*   --die-on-notes
#*                     Terminate script immediately if notes are raised.
#*
#*   --help, --usage
#*                     Output a short usage message (this message) and exit.
#*   --version
#*                     Output version information and exit.
#**
@ARGV = getOptions(
    '-d,--dictionaries'    => sub{ @dict_files = split m/,|\s+/, get_value() },
    '-D,--add-dictionary'  => sub{ push @dict_files, get_value() },
    '--clear-dictionaries' => sub{ @dict_files = () },

    '--verbose'            => sub{ $verbose = 1 },
    '--no-verbose'         => sub{ $verbose = 0 },

    '--report-deprecated'               => sub{ $report_deprecated = 1 },
    '--ignore-deprecated'               => sub{ $report_deprecated = 0 },

    '--report-local-tags'               => sub{ $report_local_tags = 1 },
    '--no-report-local-tags'            => sub{ $report_local_tags = 0 },
    '--ignore-local-tags'               => sub{ $report_local_tags = 0 },

    '--report-missing-su'               => sub{ $report_missing_su = 1 },
    '--no-report-missing-su'            => sub{ $report_missing_su = 0 },
    '--ignore-missing-su'               => sub{ $report_missing_su = 0 },

    '--continue-on-errors'          => sub { $die_on_errors = 0 },
    '--die-on-errors'               => sub { $die_on_errors = 1 },

    '--continue-on-warnings' => sub { $die_on_warnings = 0 },
    '--die-on-warnings'      => sub { $die_on_warnings = 1 },

    '--continue-on-notes'    => sub { $die_on_notes = 0 },
    '--die-on-notes'         => sub { $die_on_notes = 1 },

    '--options'         => sub{ options; exit },
    '--help,--usage'    => sub{ usage; exit },
    '--version'      => sub { print 'cod-tools version ',
                                 $COD::ToolsVersion::Version, "\n";
                                 exit }
);

my $die_on_error_level = {
    'ERROR'   => $die_on_errors,
    'WARNING' => $die_on_warnings,
    'NOTE'    => $die_on_notes
};

my %dicts;
if( @dict_files ) {
    my $options = { 'parser' => $use_parser, 'no_print' => 1 };
    foreach my $dict ( @dict_files ) {
        my ( $data, $err_count, $messages ) = parse_cif( $dict, $options );
        process_parser_messages( $messages, $die_on_error_level );
        # TODO: warn if there are more than 1 data block in a file?
        my $dict_block = $data->[0];
        my($filename, $dirs, $suffix) = fileparse($dict);
        my $imported_data = get_imported_files(
            {
                'container_file' => $dict_block,
                # TODO: the path should also be constructed from the command line
                # arguments as well as a command line variable
                'file_path'      => [ './', $dirs ],
                'imported_files' => {},
                'parser_options' => $options
            }
        );
        $dict_block   = merge_imported_files( $dict_block, $imported_data );
        $dicts{$dict} = build_search_struct( $dict_block );
    }
} else {
    report_message( {
        'program'   => $0,
        'err_level' => 'ERROR',
        'message'   => 'at least one dictionary file should be provided by '
                     . 'using the \'--dictionaries\' option. Automatic '
                     . 'dictionary download is not implemeted yet'
    }, $die_on_errors );
    my $dict_iucr_uri = 'ftp://ftp.iucr.org/pub/cif_core.dic';
};

#for my $name ( sort keys %dicts ) {
#    my $dict = $dicts{$name};
#
#    local $SIG{__WARN__} = sub { process_warnings( {
#                                   'message'       => @_,
#                                   'program'       => $0,
#                                 }, $die_on_error_level ) };
#
#    for my $save_block ( @{$dict->{'Datablock'}{'save_blocks'}} ) {
#        if ( defined $save_block->{'values'}{'_definition.class'} &&
#             uc $save_block->{'values'}{'_definition.class'}[0] eq 'HEAD' ) {
#            next;
#        }
#        my $category_id = $save_block->{'values'}{'_name.category_id'}[0];
#        my $category = $dict->{'Category'}{lc $category_id};
#
#        # This should not happen in a proper dictionary
#        if ( !defined $category ) {
#            warn "the definition of the '$save_block->{'values'}{'_definition.id'}[0]' " .
#                "data item seems to be incorrect in the '$dict->{'Datablock'}{'name'}' " .
#                "dictionary -- the item is defined as belonging to the " .
#                 "'$category_id' category which is not provided in the " .
#                 "given dictionary\n";
#                next;
#            }
#    }
#}

@ARGV = ('-') unless @ARGV;

my $validation_options = {
    'report_deprecated' => $report_deprecated,
    'report_missing_su' => $report_missing_su,
    'verbose'           => $verbose
};

for my $filename ( @ARGV ) {
    my $options = { 'parser' => $use_parser, 'no_print' => 1 };
    my ( $data, $err_count, $messages ) = parse_cif( $filename, $options );
    process_parser_messages( $messages, $die_on_error_level );
    my (undef, $dirs, undef) = fileparse($filename);

    for my $datablock ( @{$data} ) {
      my $dataname = 'data_' . $datablock->{'name'};
      local $SIG{__WARN__} = sub { process_warnings( {
                                     'message'       => @_,
                                     'program'       => $0,
                                     'filename'      => $filename,
                                     'add_pos'       => $dataname
                                   }, $die_on_error_level ) };

        my $imported_data = get_imported_files(
            {
            'container_file' => $datablock,
            # TODO: the path should also be constructed from the command line
            # arguments as well as a command line variable
            'file_path'      => [ './', $dirs ],
            'imported_files' => {},
            'parser_options' => $options
            }
        );

      $datablock = merge_imported_files( $datablock, $imported_data );
      my $struct = build_search_struct($datablock);

      my @validation_messages;
      for my $name ( sort keys %dicts ) {
        my $dict = $dicts{$name};

        # NOTE: the DDLm dictionary contains a special data structure that
        # defines which data items are mandatory, recommended and forbidden
        # in certain dictionary scopes (Dictionary, Category, Item)
        my $application_scope = extract_application_scope($dict);
        if ( defined $application_scope ) {
            push @validation_messages,
                 map {
                    sprint_message( $0, $filename, $dataname, 'WARNING', $_, undef )
                 } @{validate_application_scope( $datablock, $application_scope )};
        }

        push @validation_messages,
             map {
                sprint_message( $0, $filename, $dataname, 'WARNING', $_, undef )
             } @{validate_data_frame( $datablock, $dict, $validation_options )};

        # DDLm dictionaries contain save frames
        for my $save_frame ( @{ $datablock->{'save_blocks'} } ) {
            push @validation_messages,
                 map {
                    sprint_message(
                        $0, $filename,
                        $dataname . ' save_' . $save_frame->{'name'},
                       'WARNING', $_, undef
                    )
                 } @{validate_data_frame( $save_frame, $dict, $validation_options )};
        }
      }

      push @validation_messages,
          map {
            sprint_message( $0, $filename, $dataname, 'WARNING', $_, undef )
          } @{report_unrecognised_data_names( $datablock, \%dicts, $report_local_tags )};

      print $_ for ( @validation_messages );
    }
}

# TODO: eligibility of su values
sub validate_data_frame
{
    my ($data_frame, $dict, $options) = @_;

    my @validation_messages;

    push @validation_messages, @{validate_type_contents($data_frame, $dict)};
    push @validation_messages, @{validate_enumerators($data_frame, $dict)};
    push @validation_messages, @{validate_range($data_frame, $dict)};
    push @validation_messages, @{validate_type_container($data_frame, $dict)};
    push @validation_messages, @{validate_loops($data_frame, $dict)};
    push @validation_messages, @{validate_aliases($data_frame, $dict)};
    if ( $options->{'report_deprecated'} ) {
        push @validation_messages, @{report_deprecated($data_frame, $dict)};
    }
    push @validation_messages, @{validate_linked_items($data_frame, $dict)};
    if ( $options->{'report_missing_su'} ) {
        push @validation_messages,
                @{validate_measurement_items(
                    $data_frame, $dict,
                    { 'verbose' => $options->{'verbose'} }
                )};
    }

    return \@validation_messages;
}

sub report_unrecognised_data_names
{
    my ($data_frame, $dicts, $report_local_tags) = @_;

    my @validation_messages;

    my @tags = @{get_data_names($data_frame)};
    if ( !$report_local_tags ) {
        @tags = grep { $_ !~ m/^_\[local\]/ } @tags;
    }

    for my $dict ( values %{$dicts} ) {
        @tags = grep { !exists $dict->{'Item'}{lc $_} } @tags;
    }

    @validation_messages = map {
              "data item '$_' was not found in the provided dictionaries";
          } @tags;

    return \@validation_messages;
}

sub validate_measurement_items
{
    my ($data_frame, $dict, $options) = @_;

    $options = {} if !defined $options;
    my $verbose = defined $options->{'verbose'} ? $options->{'verbose'} : 0;

    my @validation_messages;

    for my $tag ( @{$data_frame->{'tags'}} ) {
      next if ( !exists $dict->{'Item'}{$tag} );

      my $dict_item = $dict->{'Item'}{$tag};
      next if ( get_type_purpose( $dict_item ) ne 'measurand');

      # Getting su values provided using the parenthesis notation
      my $parenthesis_su_values = extract_parenthesis_su_values( $data_frame, $tag );

      # Getting names of related su data items that
      # are present in the data frame
      my @su_data_names = @{ get_su_data_item_names( $dict, $data_frame, $tag ) };

      if ( @su_data_names ) {
        my $su_data_name = lc $su_data_names[0];
        my $data_item_su_values = $data_frame->{'values'}{$su_data_name};
        for ( my $i = 0; $i < @{$data_frame->{'values'}{$tag}}; $i++ ) {
            if ( defined $parenthesis_su_values->[$i] ) {
                if ( $parenthesis_su_values->[$i] eq '?' ||
                     $parenthesis_su_values->[$i] eq 'NaN' ) {
                    next;
                }
                next if (  has_special_value( $data_frame, $su_data_name, $i ) );
                next if ( !has_numeric_value( $data_frame, $su_data_name, $i ) );
                if ( $data_item_su_values->[$i] ne $parenthesis_su_values->[$i] ) {
                    push @validation_messages,
                        "data item $tag value '$data_frame->{'values'}{$tag}[$i]' " .
                        'has an ambiguous standard uncertainty value -- values ' .
                        'provided using the parenthesis notation ' .
                        "('$parenthesis_su_values->[$i]') and the $su_data_name " .
                        "data item ('$data_item_su_values->[$i]') " .
                        'do not match.';
                }
            }
        }
      } else {
        my @local_validation_messages;
        for ( my $i = 0; $i < @{$parenthesis_su_values}; $i++ ) {
          if ( !defined $parenthesis_su_values->[$i] ) {
            push @local_validation_messages,
                 "data item $tag value '$data_frame->{'values'}{$tag}[$i]' " .
                 'violates content purpose constraints -- data values ' .
                 'of the \'Measurand\' type must have their standard ' .
                 'uncertainties provided';
          }
        }

        if ( !$verbose && @local_validation_messages ) {
            push @validation_messages,
               "data item $tag violates the 'Measurand' content purpose " .
               'constraints -- at least one data value does not have its ' .
               'standard uncertainty provided';
        } else {
          push @validation_messages, @local_validation_messages;
        }
      }

    }

    return summarise_messages( \@validation_messages );
}

sub validate_aliases
{
    my ($data_frame, $dict) = @_;

    my @validation_messages;

    my $alias_groups = cluster_aliases( $data_frame, $dict );
    for my $key ( sort keys %{$alias_groups} ) {
        my $alias_group = $alias_groups->{$key};
        # TODO: currently, looped data items are silently skipped.
        # They should be properly validated or at least reported
        next if any { @{$data_frame->{'values'}{$_}} > 1 } @{$alias_group};

        my $type_contents = get_type_contents( $alias_group->[0],
                                               $data_frame,
                                               $dict );
        my $first_value = $data_frame->{'values'}{$alias_group->[0]}[0];
        if ( any { !compare_ddlm_values(
                $first_value,
                $data_frame->{'values'}{$_}[0],
                $type_contents ) } @{$alias_group} ) {
            push @validation_messages,
                 'incorrect usage of data item aliases -- ' .
                 'data names [' .
                  ( join ', ', map { "'$_'" } @{$alias_group} ) .
                 '] refer to the same data item, but have differing ' .
                 'values [' .
                  ( join ', ', map { "'$data_frame->{'values'}{$_}[0]'" }
                                                @{$alias_group} ) .
                 ']';
        }
    }

    return \@validation_messages;
}

sub cluster_aliases
{
    my ( $data_frame, $dict ) = @_;

    my %alias_groups;
    for my $tag ( @{$data_frame->{'tags'}} ) {
      if ( exists $dict->{'Item'}{$tag} ) {
        my $dict_item = $dict->{'Item'}{$tag};
        my $data_names = get_data_alias($dict_item);
        next if !@{$data_names};
        my $key = build_data_name_key($data_names);
        push @{ $alias_groups{$key} }, $tag;
      }
    };

    for my $key ( keys %alias_groups ) {
        if ( @{$alias_groups{$key}} < 2 ) {
            delete $alias_groups{$key};
        }
    }

    return \%alias_groups;
}

sub build_data_name_key
{
    my ($data_names) = @_;

    my $join_char = "\x{001E}";
    return join $join_char, sort map { lc } @{$data_names};
}

##
# Extracts the standard uncertainty (s.u.) values expressed using the
# parenthesis notation from all values of the given data item.
#
# @param $frame
#       Data frame that contains the data item as returned by the CIF::COD::Parser.
# @param $data_name
#       Name of the data item.
# @return $su_values
#       Array reference to a list of extracted s.u. values. For more
#       information about the potential return values consult the
#       extract_parenthesis_su_value() subroutine.
##
sub extract_parenthesis_su_values
{
    my ( $data_frame, $data_name ) = @_;

    my @su_values;
    for (my $i = 0; $i < @{$data_frame->{'values'}{$data_name}}; $i++) {
        push @su_values, extract_parenthesis_su_value($data_frame, $data_name, $i );
    }

    return \@su_values;
}

sub get_su_data_item_names
{
    my ( $dict, $data_frame, $data_name ) = @_;

    my @su_data_names;

    for my $su_data_name ( @{$data_frame->{'tags'}} ) {
        next if !is_su_pair( $dict, $data_name, $su_data_name );

        my $su_item = $dict->{'Item'}{$su_data_name};
        for ( @{ get_all_data_names( $su_item ) } ) {
            if ( exists $data_frame->{'values'}{$_} ) {
                push @su_data_names, $_;
            }
        }
    }

    return \@su_data_names;
}

sub is_su_pair
{
    my ( $dict, $data_name, $su_data_name ) = @_;

    if ( exists $dict->{'Item'}{ lc $su_data_name } ) {
        my $su_item = $dict->{'Item'}{ lc $su_data_name };
        return 0 if get_type_purpose( $su_item ) ne 'su';

        if ( exists $su_item->{'values'}{'_name.linked_item_id'} ) {
          my $linked_data_name = lc $su_item->{'values'}{'_name.linked_item_id'}[0];
          if ( exists $dict->{'Item'}{$linked_data_name} ) {
              my $linked_data_item = $dict->{'Item'}{$linked_data_name};
              my @linked_item_names = @{ get_all_data_names( $linked_data_item ) };
              if ( any { uc $data_name eq uc $_ } @linked_item_names ) {
                  return 1;
              }
          }
        }
    }

    return 0;
}

##
# Extracts the standard uncertainty (s.u.) value expressed using the
# parenthesis notation. One of the four types of s.u. values might be
# returned based on the data value:
#   - numeric value (i.e. 0.01) for numeric data values with s.u. values
#     (i.e. 1.23(1));
#   - undef value for numeric values with no s.u. values (i.e. 1.23);
#   - '?' string for special CIF values (unquoted '?' or '.' symbols);
#   - 'NaN' string for non-numeric values (i.e. 'text').
#
# Note, that according to the working specification of CIF 1.1 quoted numeric
# values (i.e. '1.23') should be treated as non-numeric values.
#
# @param $frame
#       Data frame that contains the data item as returned by the CIF::COD::Parser.
# @param $data_name
#       Name of the data item.
# @param $index
#       The index of the data item value.
# @return $su_value
#       The extracted s.u. value in the specified notation.
##
sub extract_parenthesis_su_value
{
    my ( $data_frame, $data_name, $index ) = @_;

    my $su_value;
    if ( has_special_value($data_frame, $data_name, $index ) ) {
        $su_value = '?';
    } else {
        if ( has_numeric_value( $data_frame, $data_name, $index ) ) {
            my ($number, $su) =
                unpack_cif_number( $data_frame->{'values'}{$data_name}[$index] );
            $su_value = $su;
        } else {
            $su_value = 'NaN';
        }
    }

    return $su_value;
}

##
# Checks the relationship constraints between linked data items. Missing
# linked data items as well as values unique to the foreign key are
# reported.
# @param $data_frame
#       Data frame that should be validated as returned by the CIF::COD::Parser.
# @param $dict
#       The data structure of the validation dictionary as returned by the
#       COD::CIF::DDL::DDLm::build_search_struct() subroutine.
# @return
#       Array reference to a list of validation messages.
##
sub validate_linked_items
{
    my ($data_frame, $dict) = @_;

    my @validation_messages;

    for my $tag ( @{$data_frame->{'tags'}} ) {
        next if !exists $dict->{'Item'}{$tag};

        my $dict_item = $dict->{'Item'}{$tag};
        next if !exists $dict_item->{'values'}{'_name.linked_item_id'};

        my @linked_item_names = ( lc $dict_item->{'values'}{'_name.linked_item_id'}[0] );
        # Check if the linking data item stores the su values
        my $is_su = ( get_type_purpose( $dict_item ) eq 'su' );
        # Retrieve the aliases of the linked data item
        if ( exists $dict->{'Item'}{$linked_item_names[0]} ) {
            push @linked_item_names, map { lc }
                 @{ get_data_alias( $dict->{'Item'}{$linked_item_names[0]} ) };
        } else {
            warn 'missing data item definition in the DDLm dictionary -- ' .
                 "the $tag data item is defined as being linked to the " .
                 "$linked_item_names[0] data item, however, the definition " .
                 'of the linked data item is not provided' . "\n";
        }

        # filtering out special CIF values ('?' and '.')
        my @data_item_values;
        for ( my $i = 0; $i < @{$data_frame->{'values'}{$tag}}; $i++ ) {
          if ( !has_special_value( $data_frame, $tag, $i ) ) {
              push @data_item_values,
                   $data_frame->{'values'}{$tag}[$i];
          }
        };

        my $linked_item_found = 0;
        for my $linked_item_name (@linked_item_names) {
          if ( exists $data_frame->{'values'}{$linked_item_name} ) {
            $linked_item_found = 1;
            # SU are not required to match the linked data item values
            next if $is_su;
            my %candidate_key_values = map { $_ => 1 }
                  @{$data_frame->{'values'}{$linked_item_name}};
            my @unmatched = uniq sort grep { !exists $candidate_key_values{$_} }
                  @data_item_values;
            push @validation_messages,
                  map { "the '$tag' data item contains value '$_' that was " .
                        'not found among the values of the linked ' .
                        "'$linked_item_name' data item" } @unmatched;
            last;
          }
        }

        if (!$linked_item_found) {
          push @validation_messages,
                  "the '$linked_item_names[0]' data item is required by the " .
                  "'$tag' data item, but was not found";
        }
    }

    return \@validation_messages;
}

##
# Checks the content type against the DDLm dictionary file.
# @param $data_frame
#       Data frame that should be validated as returned by the CIF::COD::Parser.
# @param $dict
#       The data structure of the validation dictionary as returned by the
#       COD::CIF::DDL::DDLm::build_search_struct() subroutine.
# @return
#       Array reference to a list of validation messages.
##
sub validate_type_contents
{
    my ($data_frame, $dict) = @_;

    my @validation_messages;

    for my $tag ( @{$data_frame->{'tags'}} ) {
        next if !exists $dict->{'Item'}{$tag};

        my $type_contents = get_type_contents( $tag, $data_frame, $dict );
        for (my $i = 0; $i < @{$data_frame->{'values'}{$tag}}; $i++) {
        my $value = $data_frame->{'values'}{$tag}[$i];
        push @validation_messages,
             map { "data item '$tag' " . $_ }
                    @{ check_data_types( $value, $type_contents,
                       $data_frame->{'types'}{$tag}[$i] ) };
        }
    }

    return \@validation_messages;
}

sub check_data_types
{
    my ($value, $type_in_dict, $type_in_parser) = @_;

    my @validation_messages;

    if ( ref $value eq '' ) {
        # skip special CIF values '?', '.'
        if ( ( $value eq '?' || $value eq '.' ) &&
             $type_in_parser eq 'UQSTRING' ) {
            return \@validation_messages;
        };

        push @validation_messages,
                 @{ check_data_type( $value, $type_in_dict ) };

        if ( !@validation_messages &&
             ( uc $type_in_dict eq 'COUNT'   ||
               uc $type_in_dict eq 'INDEX'   ||
               uc $type_in_dict eq 'INTEGER' ||
               uc $type_in_dict eq 'REAL' ) &&
             $type_in_parser ne 'FLOAT' &&
             $type_in_parser ne 'INT' ) {
            push @validation_messages,
                 'numeric values should be written without the use of quotes ' .
                 'or multiline value designators'
        }

        @validation_messages = map {
            "value '$value' violates content type constraints -- $_"
        } @validation_messages;
    } elsif ( ref $value eq 'ARRAY' ) {
        for (my $i = 0; $i < @{$value}; $i++ ) {
            push @validation_messages,
                 @{ check_data_types( $value->[$i], $type_in_dict,
                                      $type_in_parser->[$i] ) };
        }
    } elsif ( ref $value eq 'HASH' ) {
        for my $key ( keys %{$value} ) {
            push @validation_messages,
                 @{ check_data_types( $value->{$key}, $type_in_dict,
                                      $type_in_parser->{$key} ) };
        }
    } else {
       warn 'Handling of the \'', ref $value, '\' Perl reference in data type ' .
            'validation is not yet implemented';
    }

    return \@validation_messages;
}

##
# Checks the value against the DDLm data type constraints.
#
# The validation rules for imaginary, complex, binary, octal and
# hexadecimal types were based on the "Draft specifications of the
# dictionary relational expression language dREL" document
# (https://www.iucr.org/__data/assets/pdf_file/0007/16378/dREL_spec_aug08.pdf).
#
# @param $value
#       The data value that is being validated.
# @param $type
#       The declared data type of the value.
# @return
#       Array reference to a list of validation messages.
##
sub check_data_type
{
    my ($value, $type) = @_;

    # CIF2 characters according to the EBNF grammar:
    # https://www.iucr.org/__data/assets/text_file/0009/112131/CIF2-ENBF.txt
    #
    # U+0009, U+000A, U+000D, U+0020-U+007E, U+00A0-U+D7FF, U+E000-U+FDCF,
    # U+FDF0-U+FFFD, U+10000-U+1FFFD, U+20000-U+2FFFD, U+30000-U+3FFFD,
    # U+40000-U+4FFFD, U+50000-U+5FFFD, U+60000-U+6FFFD, U+70000-U+7FFFD,
    # U+80000-U+8FFFD, U+90000-U+9FFFD, U+A0000-U+AFFFD, U+B0000-U+BFFFD,
    # U+C0000-U+CFFFD, U+D0000-U+DFFFD, U+E0000-U+EFFFD, U+F0000-U+FFFFD,
    # U+100000-U+10FFFD
    my $cif2_ws_character = '\x{0009}' . '\x{000A}' . '\x{000D}' . '\x{0020}';
    my $cif2_nws_character = '\x{0021}-\x{007E}' . '\x{00A0}-\x{D7FF}' .
     '\x{E000}-\x{FDCF}' . '\x{FDF0}-\x{FFFD}' . '\x{10000}-\x{1FFFD}' .
     '\x{20000}-\x{2FFFD}' . '\x{30000}-\x{3FFFD}' . '\x{40000}-\x{4FFFD}' .
     '\x{50000}-\x{5FFFD}' . '\x{60000}-\x{6FFFD}' . '\x{70000}-\x{7FFFD}' .
     '\x{80000}-\x{8FFFD}' . '\x{90000}-\x{9FFFD}' . '\x{A0000}-\x{AFFFD}' .
     '\x{B0000}-\x{BFFFD}' . '\x{C0000}-\x{CFFFD}' . '\x{D0000}-\x{DFFFD}' .
     '\x{E0000}-\x{EFFFD}' . '\x{F0000}-\x{FFFFD}' . '\x{100000}-\x{10FFFD}';

    my $u_int   = '[0-9]+';
    my $int     = "[+-]?${u_int}";
    my $exp     = "[eE][+-]?${u_int}";
    my $u_float = "(?:${u_int}${exp})|(?:[0-9]*[.]${u_int}|${u_int}+[.])(?:$exp)?";
    my $float   = "[+-]?(?:${u_float})";

    my $cif2_character = $cif2_ws_character . $cif2_nws_character;

    my @validation_messages;

    $type = lc $type;
    if ( $type eq 'text' ) {
        # case-sensitive sequence of CIF2 characters
        if ( $value =~ m/([^$cif2_character])/ ) {
            push @validation_messages,
                 "the '$1' symbol does not belong to the permitted symbol set";
        }
    } elsif ( $type eq 'code' ) {
        # case-insensitive sequence of CIF2 characters containing
        # no ASCII whitespace
        if ( $value =~ m/([^$cif2_nws_character])/ ) {
            push @validation_messages,
                "the '$1' symbol does not belong to the permitted symbol set";
        }
    } elsif ( $type eq 'name' ) {
        # case-insensitive sequence of ASCII alpha-numeric characters
        # or underscore
        if ( $value =~ m/([^_A-Za-z0-9])/ ) {
            push @validation_messages,
                "the '$1' symbol does not belong to the permitted symbol set";
        }
    } elsif ( $type eq 'tag' ) {
        # case-insensitive CIF2 character sequence with leading
        # underscore and no ASCII whitespace
        if ( $value !~ m/^_/ ) {
            push @validation_messages,
                'the value must start with an underscore (\'_\') symbol';
        }
        if ( $value =~ m/([^$cif2_nws_character])/ ) {
            push @validation_messages,
                 "the '$1' symbol does not belong to the permitted symbol set";
        }
    } elsif ( $type eq 'filename' ) {
        # case-sensitive string identifying an external file
    } elsif ( $type eq 'uri' ) {
        # A Uniform Resource Identifier per RFC 3986
        # TODO: implement proper URI parsing as per RFC 3986
        my ($scheme, $auth, $path, $query, $frag) = uri_split($value);
        if (defined $scheme) {
            if ( $scheme =~ /^[^A-Za-z]/ ) {
                push @validation_messages, "the URI scheme component '$scheme' " .
                    'must start with an ASCII letter ([A-Za-z])';
            }
            if ( $scheme =~ /([^A-Za-z0-9.+-])/ ) {
                push @validation_messages, "the '$1' symbol is not allowed " .
                    "in the URI scheme component '$scheme'";
            };
        } else {
            push @validation_messages,
                 'an URI string must start with a scheme component';
        }
    } elsif ( $type eq 'date' ) {
        # ISO standard date format <yyyy>-<mm>-<dd>.
        # Use DateTime for all new dictionaries
        eval {
            parse_date($value);
        };
        if ( $@ ) {
            push @validation_messages,
                 'the value should conform to the ISO standard date format ' .
                 '<yyyy>-<mm>-<dd>';
        }
    } elsif ( $type eq 'datetime' ) {
        # A timestamp. Text formats must use date-time or
        # full-date productions of RFC3339 ABNF
        eval {
            parse_datetime($value);
        };
        if ( $@ ) {
            push @validation_messages,
                 'the value should be a date-time or full-date production ' .
                 'of RFC339 ABNF';
        }
    } elsif ( $type eq 'version' ) {
        # version digit string of the form <major>.<version>.<update>
        if ( $value !~ m/^[0-9]+(?:\.[0-9]+){0,2}$/ ) {
            push @validation_messages,
                 'the value should be a version digit string of the form ' .
                 '<major>.<version>.<update>';
        }
    } elsif ( $type eq 'dimension' ) {
        # integer limits of an Array/Matrix/List in square brackets
        push @validation_messages,
                 'validation of the \'dimension\' type data items is not yet ' .
                 'implemented';
    } elsif ( $type eq 'range' ) {
        # inclusive range of numerical values min:max
        # TODO: are letters allowed in ranges?
        my $range = parse_range($value);
        my $lower = $range->[0];
        my $upper = $range->[1];
        if ( ( !defined $lower || $lower !~ /^$int|$float$/ ) &&
             ( !defined $upper || $upper !~ /^$int|$float$/ ) ) {
            push @validation_messages,
                 'the value should be a range of numerical values of ' .
                 'the form \'min:max\'';
        } elsif ( defined $lower && defined $upper ) {
            if ( $lower > $upper ) {
                push @validation_messages,
                    "the lower range value '$lower' is greater than the upper " .
                    "range value '$upper'";
            }
        }
    } elsif ( $type eq 'count' ) {
        # unsigned integer number
        $value =~ s/\([0-9]+\)$//;
        if ( $value !~ m/^[0-9]+$/ ) {
            push @validation_messages,
                 'the value should be an unsigned integer';
        }
    } elsif ( $type eq 'index' ) {
        # unsigned non-zero integer
        $value =~ s/\([0-9]+\)$//;
        if ( $value !~ m/^[0-9]+$/ || $value <= 0 ) {
            push @validation_messages,
                 'the value should be an unsigned non-zero integer';
        }
    } elsif ( $type eq 'integer' ) {
        # positive or negative integer
        $value =~ s/\([0-9]+\)$//;
        if ( $value !~ m/^[-+]?[0-9]+$/ ) {
            push @validation_messages,
                 'the value should be an integer';
        }
    } elsif ( $type eq 'real' ) {
        # floating-point real number
        $value =~ s/\([0-9]+\)$//;
        if ( $value !~ m/^(:?$int|${float})$/ ) {
            push @validation_messages,
                 'the value should be a floating-point real number';
        }
    } elsif ( $type eq 'imag' ) {
        # floating-point imaginary number
        if ( $value !~ m/^(:?${int}|${float})[jJ]$/ ) {
            push @validation_messages,
                 'the value should be a floating-point imaginary number ' .
                 'expressed as a real number with the imaginary unit suffix ' .
                 '\'j\' , i.e. -42j';
        }
    } elsif ( $type eq 'complex' ) {
        # complex number <R>+j<I>
        if ( $value !~ m/^(?:$int|${float})[+-](?:${u_int}|${u_float})[jJ]$/ ) {
            push @validation_messages,
                 'the value should be a complex number consisting of a real ' .
                 'part expressed as a real number and the imaginary ' .
                 'part expressed as a real number with the imaginary unit ' .
                 'suffix \'j\', i.e. -3.14+42j';
        }
    } elsif ( $type eq 'binary' ) {
        # binary number \b<N>
        if ( $value !~ m/^[0][bB][01]+$/ ) {
            push @validation_messages,
                'the value should be a binary number expressed in ' .
                'notation that matches the \'^[0][bB][01]+$\' ' .
                'regular expression';
        }
    } elsif ( $type eq 'octal' ) {
        # octal number \o<N>
        if ( $value !~ m/^[0][oO][0-7]+$/ ) {
            push @validation_messages,
                 'the value should be an octal number expressed in ' .
                 'notation that matches the \'^[0][oO][0-7]+$\' ' .
                 'regular expression';
        }
    } elsif ( $type eq 'hexadecimal' ) {
        # hexadecimal number \x<N>
        if ( $value !~ m/^[0][xX][0-9a-fA-F]+$/ ) {
            push @validation_messages,
                 'the value should be an hexadecimal number expressed in ' .
                 'notation that matches the \'^[0][xX][0-9a-fA-F]+$\' ' .
                 'regular expression';
        }
    } elsif ( $type eq 'symop' ) {
        if ( $value !~ /^[-+]?[0-9]*(?:[_ ][0-9]{3,})?$/) {
            push @validation_messages,
                'the value should be a string composed of an integer ' .
                'optionally followed by an underscore or space and ' .
                'three or more digits';
        }
    } elsif ( $type eq 'implied' ) {
        # implied by the context of the attribute
        push @validation_messages,
                 'validation of the \'implied\' type data items is not yet ' .
                 'implemented';
    } elsif ( $type eq 'byreference' ) {
        # The contents have the same form as those of the attribute
        # referenced by _type.contents_referenced_id.
        push @validation_messages,
                 'validation of the \'byreference\' type data items is not yet ' .
                 'implemented';
    } else {
        warn "content type '$type' is not recognised\n";
    }

    return \@validation_messages;
}

##
# Checks the container types against the DDLm dictionary file.
# @param $data_frame
#       Data frame that should be validated as returned by the CIF::COD::Parser.
# @param $dict
#       The data structure of the validation dictionary as returned by the
#       COD::CIF::DDL::DDLm::build_search_struct() subroutine.
# @return
#       Array reference to a list of validation messages.
##
sub validate_type_container
{
    my ($data_frame, $dict) = @_;

    my @validation_messages;

    for my $tag ( @{$data_frame->{'tags'}} ) {
        next if ( !exists $dict->{'Item'}{$tag} );

        my $type_container = lc get_type_container( $dict->{'Item'}{$tag} );
        my $value = $data_frame->{'values'}{$tag}[0];
        if ( $type_container eq 'single' ) {
            if ( ref $value ne '' ) {
                 push @validation_messages,
                      "data item '$tag' value must not have " .
                      'a top level container';
            }
        } elsif ( $type_container eq 'multiple' ) {
        # TODO: implement Multiple type check
        } elsif ( $type_container eq 'array' ) {
        # TODO: implement Array type check
        } elsif ( $type_container eq 'matrix') {
        # TODO: implement Matrix type check
        } elsif ( $type_container eq 'list' ) {
            if ( ref $value ne 'ARRAY' ) {
              push @validation_messages,
                   "data item '$tag' value must have a top level " .
                   'list container ([v1 v2 ...])';
            }
        } elsif ( lc $type_container eq lc 'table' ) {
            if ( ref $value ne 'HASH' ) {
              push @validation_messages,
                   "data item '$tag' value must have a top level " .
                   'table container ({k1:v1 k2:v2 ...})';
            }
        }
    }

    return \@validation_messages;
}

##
# Checks enumerator values against the DDLm dictionary file.
# @param $data_frame
#       Data frame that should be validated as returned by the CIF::COD::Parser.
# @param $dict
#       The data structure of the validation dictionary as returned by the
#       COD::CIF::DDL::DDLm::build_search_struct() subroutine.
# @return
#       Array reference to a list of validation messages.
##
sub validate_enumerators
{
    my ($data_frame, $dict) = @_;

    my @validation_messages;

    for my $tag ( @{$data_frame->{'tags'}} ) {
        next if ( !exists $dict->{'Item'}{$tag} );

        my $dict_item = $dict->{'Item'}{$tag};
        next if ( !exists $dict_item->{'values'}{'_enumeration_set.state'} );

        my @enumeration_values = @{
                            $dict_item->{'values'}
                            {'_enumeration_set.state'} };
        my $type_container = lc get_type_container( $dict_item );

        for (my $i = 0; $i < @{$data_frame->{'values'}{$tag}}; $i++) {
            my $value = $data_frame->{'values'}{$tag}[$i];
            if ( $type_container eq 'single' ) {
                next if has_special_value($data_frame, $tag, $i);

                # FIXME: fc should probably be used instead of uc, but
                # it is not supported by older Perl versions
                if (! any { uc $value eq uc $_ } @enumeration_values ) {
                    push @validation_messages,
                      "data item '$tag' value \'$value\' "
                    . 'must be one of the enumeration values '
                    . '[' . ( join ', ', @enumeration_values ) . ']';
                }
            # !!! Mainly targeted at '_type.contents'.
            # !!! Might be deprecated soon.
            } elsif ( $type_container eq 'multiple' ) {
                if (! any { uc $value  eq uc $_ } @enumeration_values ) {
                    #     print "$instance: $tag: $value is not permitted\n";
                    #  warn "data item '$tag' value \"$value\" "
                    #     . 'must be one of the enumeration values '
                    #     . '[' . ( join ', ', @enumeration_values ) . ']. '
                    #     . 'This message might be a false positive since '
                    #     . 'handling of enumeration values with the '
                    #     . "'Multiple' type container is not yet implemented\n";
                }
            # TODO: consider all of these combinations?
            # even if they don't really occur?
            } elsif ( $type_container eq 'array' ) {

            } elsif ( $type_container eq 'matrix') {

            } elsif ( $type_container eq 'list' ) {

            } elsif ( $type_container eq 'table' ) {

            }
        }
    }

    return summarise_messages( \@validation_messages );
}

##
# Checks loop properties against the DDLm dictionary file.
# @param $data_frame
#       Data frame that should be validated as returned by the CIF::COD::Parser.
# @param $dict
#       The data structure of the validation dictionary as returned by the
#       COD::CIF::DDL::DDLm::build_search_struct() subroutine.
# @return
#       Array reference to a list of validation messages.
##
sub validate_loops
{
    my ($data_frame, $dict) = @_;

    my @validation_messages;

    my %looped_categories;
    for my $tag ( @{$data_frame->{'tags'}} ) {
        next if !exists $dict->{'Item'}{$tag};

        my $category_id = $dict->{'Item'}{$tag}{'values'}{'_name.category_id'}[0];
        # This should not happen in a proper dictionary
        next if ( !exists $dict->{'Category'}{lc $category_id} );

        my $category = $dict->{'Category'}{lc $category_id};
        my $is_looped_category =
            (lc $category->{'values'}{'_definition.class'}[0] eq 'loop');
        my $tag_is_looped = exists $data_frame->{'inloop'}{$tag};

        if ( $is_looped_category ) {
            $looped_categories{$category_id}{$tag} = {
                'loop_id'   =>
                    ( exists $data_frame->{'inloop'}{$tag} ?
                      $data_frame->{'inloop'}{$tag} : -1 ),
                'loop_size' => scalar @{$data_frame->{'values'}{$tag}}
            };
        } elsif ( $tag_is_looped ) {
            push @validation_messages,
                "data item '$tag' must not appear in a loop";
        }
    }

    push @validation_messages,
         @{check_loop_keys( \%looped_categories, $data_frame, $dict )};

    foreach my $c (keys %looped_categories ) {
        # check if all data items appear in the same loop
        my %loops;
        foreach my $d ( keys %{$looped_categories{$c}} ) {
            $loops{$looped_categories{$c}{$d}{'loop_id'}}++;
        }
        if ( keys %loops > 1 ) {
            push @validation_messages,
                'data items ' . '[' .
                 ( join ', ', sort map { "'$_'" } keys %{$looped_categories{$c}} ) .
                ']' . ' must all appear in the same loop';
        }
    }

    return \@validation_messages;
}

##
# Checks the existence and uniqueness of loop primary keys.
# @param $looped_categories
#       Data structure that stores information about the looped
#       categories present in the provided data frame:
#
#       $looped_categories = {
#           $category_1 => {
#               {
#                   $category_1_data_name_1 => {
#                       'loop_id'   => 1  # in loop no 1
#                       'loop_size' => 5
#                    },
#                   $category.data_name_2 => {
#                       'loop_id'   => 1
#                       'loop_size' => 5
#                   },
#                   $category.data_name_3 => {
#                       'loop_id'   => -1 # unlooped
#                       'loop_size' => 1
#                   },
#                   $category.data_name_4 => {
#                       'loop_id'   => 2  # in loop no 2
#                       'loop_size' => 3
#                   },
#               },
#           $category_2 => {
#               ...
#           }
#       }
# @param $data_frame
#       Data frame in which the validate loops reside as returned
#       by the CIF::COD::Parser.
# @param $dict
#       The data structure of the validation dictionary as returned by the
#       COD::CIF::DDL::DDLm::build_search_struct() subroutine.
# @return
#       Array reference to a list of validation messages.
##
sub check_loop_keys
{
    my ( $looped_categories, $data_frame, $dict ) = @_;

    my @validation_messages;

    foreach my $c (sort keys %{$looped_categories} ) {
        # The _category.key_id data item hold the data name of a
        # single data item that acts as a primary key
        push @validation_messages,
             @{check_simple_category_key(
                $data_frame, $looped_categories, $c, $dict
             ) };

        # If the _category.key_id and _category_key.name data item values
        # are identical the validation of the latter should be skipped
        if ( exists $dict->{'Category'}{$c}{'values'}{'_category.key_id'} &&
             exists $dict->{'Category'}{$c}{'values'}{'_category_key.name'} &&
             @{$dict->{'Category'}{$c}{'values'}{'_category_key.name'}} == 1 &&
             $dict->{'Category'}{$c}{'values'}{'_category.key_id'}[0] eq
             $dict->{'Category'}{$c}{'values'}{'_category_key.name'}[0]
        ) {
            next;
        }

        # Alternatively, the _category_key.name data item contains
        # a list of data items that can function as a primary key
        push @validation_messages,
             @{check_composite_category_key(
                $data_frame, $looped_categories, $c, $dict
             ) };

    }

    return \@validation_messages;
}

sub check_simple_category_key
{
    my ( $data_frame, $looped_categories, $category, $dict ) = @_;

    my @validation_messages;

    if ( !exists $dict->{'Category'}{$category}{'values'}{'_category.key_id'} ) {
        return \@validation_messages;
    }

    my $cat_key_id = $dict->{'Category'}{$category}{'values'}{'_category.key_id'}[0];
    if ( exists $dict->{'Item'}{lc $cat_key_id} ) {
        my $cat_key_frame = $dict->{'Item'}{lc $cat_key_id};
        my $type_contents = get_type_contents(
            $cat_key_id, $data_frame, $dict
        );

        # TODO: in some cases, i.e. _atom_type_scat.symbol, the
        # linked data item (i.e. _atom_type_symbol) is used instead
        # of the appropriate tag. This should probably only raise a
        # note and not a warning
        my @data_names = @{ get_all_data_names( $cat_key_frame ) };
        @data_names = map { lc $_ } @data_names;

        my $is_key_present = 0;
        for my $data_name (@data_names) {
            if ( exists $data_frame->{'values'}{$data_name} ) {
                $is_key_present = 1;
                push @validation_messages,
                     check_key_uniqueness(
                        $data_name,
                        $data_frame,
                        $type_contents
                     );
                last;
            }
        }

        # NOTE: dREL methods sometimes define a way to evaluate the
        # data value using other data item. Since dREL is currently
        # not handled by the validator the missing value should not
        # be reported
        # TODO: implement key evaluation using dREL methods
        my $is_evaluatable = 0;
        if ( exists $cat_key_frame->{'values'}{'_method.purpose'} ) {
             $is_evaluatable = any { lc $_ eq 'evaluation' }
                    @{$cat_key_frame->{'values'}{'_method.purpose'}};
        }

        if ( !$is_key_present && !$is_evaluatable ) {
            push @validation_messages,
                'missing category key data item -- ' .
                "the '$data_names[0]' data item must be provided in the " .
                'loop containing the [' .
                 ( join ', ', sort map { "'$_'" }
                 keys %{$looped_categories->{$category}} ) .
                 '] data items';
        }
    } else {
        warn 'WARNING, missing data item definition in the DDLm ' .
             "dictionary -- the $cat_key_id data item is defined as " .
             "being the primary key of the looped '$category' category, " .
             'however, the data item definition is not provided' . "\n";
    }

    return \@validation_messages;
}

##
# Checks the loop key uniqueness constraint.
# @param $data_name
#       The data name of the data item which acts as the unique loop key.
# @param $data_frame
#       CIF data frame (data block or save block) in which the data item
#       resides as returned by the COD::CIF::Parser.
# @param $key_type
#       Content type of the key as defined in the DDLm dictionary.
# @return
#       Array reference to a list of validation messages.
##
sub check_key_uniqueness
{
    my ($data_name, $data_frame, $key_type) = @_;

    my @validation_messages;

    my %unique_values;
    for ( my $i = 0; $i < @{$data_frame->{'values'}{$data_name}}; $i++ ) {
        # TODO: special values are silently skipped, but maybe they should
        # still be reported somehow since having special value in a key
        # might not be desirable...
        next if has_special_value($data_frame, $data_name, $i);
        my $value = $data_frame->{'values'}{$data_name}[$i];
        my $canon_value = canonicalise_ddlm_value( $value, $key_type );
        push @{$unique_values{$canon_value}}, $value;
    }

    foreach my $key ( sort keys %unique_values ) {
        if ( @{$unique_values{$key}} > 1 ) {
            push @validation_messages, "data item '$data_name' acts as a " .
                 'loop key, but the associated data values are not unique -- ' .
                 "value '$key' appears " .
                 ( scalar @{$unique_values{$key}} ) . ' times as [' .
                 ( join ', ', map { "'$_'" } @{$unique_values{$key}} ) . ']';
        }
    }

    return @validation_messages;
}

sub check_composite_category_key
{
    my ( $data_frame, $looped_categories, $category, $dict ) = @_;

    my @validation_messages;

    if ( exists $dict->{'Category'}{$category}{'values'}{'_category_key.name'} ) {
        my @key_data_names;
        my $cat_key_ids = $dict->{'Category'}{$category}{'values'}{'_category_key.name'};
        for my $cat_key_id ( @{$cat_key_ids} ) {
            if ( exists $dict->{'Item'}{lc $cat_key_id} ) {
                my $cat_key_frame = $dict->{'Item'}{lc $cat_key_id};
                my $type_contents = get_type_contents(
                    $cat_key_id, $data_frame, $dict
                );

                my @data_names;
                push @data_names, @{ get_all_data_names( $cat_key_frame ) };
                @data_names = map { lc $_ } @data_names;

                my $is_key_present = 0;
                for my $data_name (@data_names) {
                    if ( exists $data_frame->{'values'}{$data_name} ) {
                        $is_key_present = 1;
                        push @key_data_names, $data_name;
                        last;
                    }
                }

                # NOTE: dREL methods sometimes define a way to evaluate the
                # data value using other data item. Since dREL is currently
                # not handled by the validator the missing value should not
                # be reported
                # TODO: implement key evaluation using dREL methods
                my $is_evaluatable = 0;
                if ( exists $cat_key_frame->{'values'}{'_method.purpose'} ) {
                     $is_evaluatable = any { lc $_ eq 'evaluation' }
                            @{$cat_key_frame->{'values'}{'_method.purpose'}};
                }

                my $has_default_value = 0;
                if ( exists $cat_key_frame->{'values'}{'_enumeration.default'} &&
                     !(has_special_value($cat_key_frame, '_enumeration.default', 0) ) ) {
                    $has_default_value = 1;
                }

                if ( !$is_key_present &&
                     !$is_evaluatable &&
                     !$has_default_value ) {
                    push @validation_messages,
                        'missing category key data item -- ' .
                        "the $data_names[0] data item must be provided in the " .
                        'loop containing the [' .
                         ( join ', ', sort map { "'$_'" }
                         keys %{$looped_categories->{$category}} ) .
                         '] data items';
                }

            } else {
                warn 'WARNING, missing data item definition in the DDLm ' .
                     "dictionary -- the $cat_key_id data item is defined as " .
                     'comprising the composite primary key of the looped ' .
                     "'$category' category, however, the data item definition " .
                     'is not provided' . "\n";
            }
        }
        push @validation_messages,
             @{ check_composite_key_uniqueness( \@key_data_names, $data_frame, $dict ) };
    }

    return \@validation_messages;
}

sub check_composite_key_uniqueness
{
    my ($data_names, $data_frame, $dict) = @_;

    my @validation_messages;

    if ( !@{ $data_names } ) {
        return \@validation_messages
    }

    my $join_char = "\x{001E}";
    my %unique_values;
    for ( my $i = 0; $i < @{$data_frame->{'values'}{$data_names->[0]}}; $i++ ) {
        my $composite_key = '';
        my @composite_key_values;
        my $has_special_value = 0;
        foreach my $data_name ( @{$data_names } ) {
            # TODO: composite keys containing special values are silently
            # skipped, but maybe they should still be reported somehow since
            # having special value in a key might render it unusable
            if ( has_special_value($data_frame, $data_name, $i) ) {
                $has_special_value = 1;
                last;
            };

            # TODO: it is really suboptimal to ask for the content type
            # each time...
            my $key_type = get_type_contents(
                $data_name, $data_frame, $dict
            );

            my $value = $data_frame->{'values'}{$data_name}[$i];
            push @composite_key_values, $value;
            $composite_key .= canonicalise_ddlm_value( $value, $key_type ) .
                              "$join_char";
        }
        if (!$has_special_value) {
            push @{$unique_values{$composite_key}}, \@composite_key_values;
        }
    }

    foreach my $key ( sort keys %unique_values ) {
        if ( @{$unique_values{$key}} > 1 ) {
            my @duplicates;
            for my $values ( @{$unique_values{$key}} ) {
                push @duplicates,
                     '[' . ( join ', ', map { "'$_'" } @{$values} ) . ']';
            }

            push @validation_messages, 'data items [' .
                 ( join ', ', map { "'$_'" } @{$data_names} ) . '] act as a ' .
                 'composite loop key, but the associated data values are ' .
                 'not unique -- values [' .
                 ( join ', ', map { "'$_'" } split /$join_char/, $key ) .
                 '] appear ' .
                 ( scalar @{$unique_values{$key}} ) . ' times as ' .
                 ( join ', ', @duplicates );
        }
    }

    return \@validation_messages;
}

sub canonicalise_ddlm_value
{
    my ( $value, $content_type ) = @_;

    $content_type = lc $content_type;

    if ( $content_type eq 'text' ||
         $content_type eq 'date' ) {
        return $value;
    }

    if ( $content_type eq 'code' ||
         $content_type eq 'name' ||
         $content_type eq 'tag' ) {
        return ( lc $value );
    }

    # TODO: proper parsing should be carried out eventually
    if ( $content_type eq 'uri' ) {
        return $value;
    }

    if ( $content_type eq 'datetime' ) {
        my $canonical_value;
        eval {
            $canonical_value = canonicalise_timestamp($value);
        };
        if ( $@ ) {
            return $value;
        }

        return $canonical_value;
    }

    if ( $content_type eq 'symop' ) {
        return $value;
    }

    # TODO: the dimension data type is currently not yet fully established
    if ( $content_type eq 'dimension' ) {
        return $value;
    }

    if ( $content_type eq 'count' ||
         $content_type eq 'index' ||
         $content_type eq 'real'
    ) {
        my $uvalue = unpack_cif_number($value);
        if ( looks_like_number( $uvalue ) ) {
            return ( $uvalue + 0 );
        } else {
            return $uvalue;
        }
    }

    return $value
}

# TODO: it should be noted, that special CIF values are handled outside of
# this function
# TODO: for now precisions are not considered
# TODO: maybe move this to a separate module, implement and test all available
# options
sub compare_ddlm_values
{
  my ( $value_1, $value_2, $content_type ) = @_;

  return ( canonicalise_ddlm_value($value_1, $content_type) eq
           canonicalise_ddlm_value($value_2, $content_type) );
}

sub report_deprecated
{
    my ($data_frame, $dict) = @_;

    my @validation_messages;

    for my $tag ( @{$data_frame->{'tags'}} ) {
      if ( exists $dict->{'Item'}{$tag} ) {
        if ( exists $dict->{'Item'}{$tag}{'values'}{'_definition.replaced_by'} ) {
          push @validation_messages,
            "the '$tag' data item has been deprecated and should " .
            'not be used -- it was replaced by the \'' .
             $dict->{'Item'}{$tag}{'values'}{'_definition.replaced_by'}[0] .
            '\' data item';
        }
      }
    }

    return \@validation_messages;
}

sub validate_range
{
    my ($data_frame, $dict) = @_;

    my @validation_messages;

    for my $tag ( @{$data_frame->{'tags'}} ) {
        next if !exists $dict->{'Item'}{$tag};

        my $dict_item = $dict->{'Item'}{$tag};
        next if !exists $dict_item->{'values'}{'_enumeration.range'};
        my $range = parse_range( $dict_item->{'values'}{'_enumeration.range'}[0] );

        for (my $i = 0; $i < @{$data_frame->{'values'}{$tag}}; $i++) {
            next if (  has_special_value($data_frame, $tag, $i) );
            next if ( !has_numeric_value($data_frame, $tag, $i) );

            my $value = $data_frame->{'values'}{$tag}[$i];
            my $old_value = $value;

            $value =~ s/\(\d+\)$//;
            if ( !is_in_range( $value, { 'range' => $range, 'type' => 'numb' } ) ) {
                push @validation_messages,
                     "data item '$tag' value '$old_value' should be in range " .
                      range_to_string($range, { 'type' => 'numb' }) ;
            }
        }
    }

    return \@validation_messages;
}

##
# Checks application scope restrictions for data items in a dictionary file.
#
# @param $data_frame
#       Data frame that should be validated as returned by the CIF::COD::Parser.
# @param $application_scope
#       Reference to a data item application scope data structure as
#       returned by the extract_application_scope() subroutine.
# @return
#       Array reference to a list of validation messages.
##
sub validate_application_scope
{
    my ($data_frame, $application_scope) = @_;

    my @validation_messages;

    my $search_struct = build_search_struct($data_frame);
    for my $scope ( 'Dictionary', 'Category', 'Item' ) {
      for my $instance ( sort keys %{$search_struct->{$scope}} ) {
        my %mandatory   = map { $_ => 0 } @{$application_scope->{$scope}{'Mandatory'}};
        my %recommended = map { $_ => 0 } @{$application_scope->{$scope}{'Recommended'}};
        my %prohibited  = map { $_ => 0 } @{$application_scope->{$scope}{'Prohibited'}};
        for my $tag ( @{$search_struct->{$scope}{$instance}{'tags'}} ) {
          if ( exists $prohibited{$tag} ) {
            # NOTE: import statements are allowed in the HEAD category
              if ( $tag eq '_import.get' &&
                   ( lc get_definition_class( $search_struct->{$scope}{$instance} ) eq 'head' ) ) {
                next;
              }
              push @validation_messages,
                   "data item '$tag' is prohibited in the '$scope' scope of " .
                   "the '$search_struct->{$scope}{$instance}{'name'}' frame";
          }
          $mandatory{$tag}   = 1 if ( exists $mandatory{$tag} );
          $recommended{$tag} = 1 if ( exists $recommended{$tag} );
        }
        for my $tag (sort keys %mandatory) {
          if ( $mandatory{$tag} == 0 ) {
            push @validation_messages,
                 "data item '$tag' is mandatory in the '$scope' scope of " .
                 "the '$search_struct->{$scope}{$instance}{'name'}' frame"
          }
        }

        for my $tag ( sort keys %recommended) {
          if ( $recommended{$tag} == 0 ) {
            # The _category_key.name and _category.key_id are recommended
            # for the CATEGORY scope, however, they make no sense if
            # the CATEGORY is unlooped
            # TODO: figure out what is the IUCr policy towards this
            if ( $scope eq 'Category' &&
                 ( lc get_definition_class( $search_struct->{$scope}{$instance} ) ne 'loop' ) &&
                 ( $tag eq '_category_key.name' || $tag eq '_category.key_id' )
            ) {
               next;
            }

            push @validation_messages,
                 "data item '$tag' is recommended in the '$scope' scope of " .
                 "the '$search_struct->{$scope}{$instance}{'name'}' frame";
          }
        }
      }
    }

    return \@validation_messages;
}

##
# Extracts the application scopes of the data items described in the given
# dictionary. This subroutine is most likely applicable only to the DDLm
# dictionary itself.
#
# @param $dict
#       The data structure of the validation dictionary as returned by the
#       COD::CIF::DDL::DDLm::build_search_struct() subroutine. Most likely
#       this dictionary will be the DDLm dictionary.
# @return $application_scope
#       Reference to a data item application scope data structure of the
#       following form:
#       {
#           'Dictionary' => {
#               'Mandatory'   => [ 'data_item_1', 'data_item_2' ],
#               'Recommended' => [ 'data_item_3' ],
#               'Prohibited'  => [ 'data_item_1' ],
#           },
#           'Category' => {
#               ...
#           },
#           'Item' => {
#               ...
#           }
#       }
##
sub extract_application_scope
{
    my ($dict) = @_;

    if ( !defined $dict->{'Datablock'}
            {'values'}{'_dictionary_valid.application'} ||
         !defined $dict->{'Datablock'}
            {'values'}{'_dictionary_valid.attributes'} ) {
        return;
    }

    my $valid_application = $dict->{'Datablock'}
                              {'values'}{'_dictionary_valid.application'};
    my $valid_attributes  = $dict->{'Datablock'}
                              {'values'}{'_dictionary_valid.attributes'};

    # The DDLm dictionary stores scope restriction data in the form:
    # [SCOPE RESTRICTION], i.e. [DICTIONARY MANDATORY]
    my %application_scope;
    for (my $i = 0; $i < @{$valid_application}; $i++) {
        $application_scope
            {$valid_application->[$i][0]}
            {$valid_application->[$i][1]} = $valid_attributes->[$i]
    };
    # expand valid attribute categories into individual data item names
    for my $scope (keys %application_scope) {
        for my $permission (keys %{$application_scope{$scope}}) {
            $application_scope{$scope}{$permission} =
                expand_categories( $application_scope{$scope}{$permission}, $dict );
        }
    }

    return \%application_scope;
}

##
# Returns the ids of all data items contained in the given categories
# and their subcategories. Recursive.
#
# @param $parent_ids
#       Array reference to a list of parent category ids. Might contain
#       data item ids which are simply copied upon encounter.
# @param $dict
#       The data structure of the validation dictionary as returned by the
#       COD::CIF::DDL::DDLm::build_search_struct() subroutine.
# @return
#       Array reference to a list of data item ids.
##
sub expand_categories
{
    my ($parent_ids, $dict) = @_;

    my @expanded_categories;
    for my $parent_id ( map { lc } @{$parent_ids} ) {
        if ( exists $dict->{'Item'}{$parent_id} ) {
            push @expanded_categories, $parent_id;
        } elsif ( exists $dict->{'Category'}{$parent_id} ) {
            for my $child_id (keys %{$dict->{'Item'}}) {
                if ( exists $dict->{'Item'}{$child_id}{'values'}{'_name.category_id'} &&
                     lc $dict->{'Item'}{$child_id}{'values'}{'_name.category_id'}[0] eq $parent_id ) {
                    push @expanded_categories, $child_id;
                }
            }
            for my $child_id (keys %{$dict->{'Category'}}) {
                if ( exists $dict->{'Category'}{$child_id}{'values'}{'_name.category_id'} &&
                     lc $dict->{'Category'}{$child_id}{'values'}{'_name.category_id'}[0] eq $parent_id ) {
                    push @expanded_categories, @{expand_categories([ $child_id ], $dict)};
                }
            }
        } else {
            die 'No such data item or category was found in dictionary';
        }
    }

    return \@expanded_categories;
}

##
# Returns an array composed of the main data name and the provided data name
# aliases.
#
# @param $data_frame
#       Data item definition frame as returned by the COD::CIF::Parser.
# @return $data_names
#       Array reference to a list of data names identifying a data item.
##
sub get_all_data_names
{
    my ( $data_frame ) = @_;

    my @data_names;
    if ( defined get_data_name( $data_frame ) ) {
        push @data_names, get_data_name( $data_frame );
    }
    push @data_names, @{ get_data_alias( $data_frame ) };
    @data_names = uniq map { lc $_ } @data_names;

    return \@data_names;
}

sub get_data_names
{
    my ( $data_block ) = @_;

    my @data_names;

    push @data_names, @{$data_block->{'tags'}};
    for my $save_block ( @{$data_block->{'save_blocks'}} ) {
        push @data_names, @{$save_block->{'tags'}};
    };

    @data_names = uniq sort map { lc } @data_names;

    return \@data_names;
}

# FIXME: the following subroutine was copied from the 'cif_fix_values'
# script. It would be better to move it into a separate module

##
# Groups identical messages together and replaces each group with a
# summarized version of the message.
# @param $messages
#       Reference to an array of error messages.
# @return $message_summary
#       Reference to an array of unique summary messages.
##
sub summarise_messages
{
    my ($messages) = @_;

    my %message_count;
    $message_count{$_}++ for @{$messages};

    my @message_summary;
    for my $message ( sort keys %message_count ) {
        my $count = $message_count{$message};
        if( $count > 1 ) {
            $message .= " ($count times)";
        }
        push @message_summary, $message;
    }

    return \@message_summary;
}
