#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#* Check dictionaries written in DDLm against the specified instance of
#* the DDLm dictionary.
#*
#* USAGE:
#*    $0 --dictionaries 'cif_core.dic,cif_cod.dic' --options input1.cif input*.cif
#**

use strict;
use warnings;
binmode STDOUT, ':encoding(UTF-8)';
binmode STDERR, ':encoding(UTF-8)';

use File::Basename qw( fileparse );
use List::MoreUtils qw( uniq );

use COD::CIF::Parser qw( parse_cif );
use COD::CIF::DDL qw( is_local_data_name );

use COD::CIF::DDL::DDLm qw( build_search_struct
                            get_imported_files
                            merge_imported_files
                            ddlm_validate_data_block );
use COD::SOptions qw( getOptions get_value );
use COD::SUsage qw( usage options );
use COD::ErrorHandler qw( process_warnings
                          process_parser_messages
                          report_message );
use COD::UserMessage qw( sprint_message );
use COD::ToolsVersion;

my $use_parser = 'c';
my $enum_as_set_tags = [ '_atom_site.refinement_flags',
                         '_atom_site_refinement_flags', ];
my $verbose = 0;
my $report_local_tags = 0;
my $report_deprecated = 0;
my $report_missing_su = 0;
my @dict_files;

my $die_on_errors   = 1;
my $die_on_warnings = 0;
my $die_on_notes    = 0;

#* OPTIONS:
#*   -d, --dictionaries 'cif_core.dic,cif_cod.dic'
#*                     A list of CIF dictionary files (according to DDLm)
#*                     to be used in CIF file validation. List elements
#*                     are separated either by ',' or by ' '. To include
#*                     dictionaries with filenames containing these symbols,
#*                     the --add-dictionary option is used.
#*   -D, --add-dictionary 'cif new dictionary.dic'
#*                     Add additional CIF dictionary to the list.
#*   --clear-dictionaries
#*                     Remove all CIF dictionaries from the list.
#*
#*   --treat-as-set _atom_site_refinement_flags
#*                     Treat values of given data items as a set. For example,
#*                     more than one enumeration value could be defined
#*                     for a single element. Any number of data items can be
#*                     specified in the following way:
#*                     $0 --treat-as-set _tag_1 --treat-as-set _tag_2
#*                     The default consists of the '_atom_site_refinement_flags'
#*                     and '_atom_site.refinement_flags' data items.
#*   --no-treat-as-set
#*                     Do not treat values of any data items as sets.
#*                     (see --treat-as-set).
#*
#*   --verbose
#*                     Output additional validation messages describing
#*                     previously grouped validation errors in more detail.
#*   --no-verbose
#*                     Do not output additional validation messages describing
#*                     previously grouped validation errors in more detail
#*                     (default).
#*
#*   --report-deprecated
#*                     Report the presence of data items that are marked as
#*                     deprecated in the dictionaries. Data item deprecation
#*                     usually means that it has been replaced with an another
#*                     data item.
#*   --ignore-deprecated
#*                     Do not report the presence of data items that are marked
#*                     as deprecated in the dictionaries (default).
#*
#*   --report-local-tags
#*                     Report the presence of local data items.
#*   --no-report-local-tags, --ignore-local-tags
#*                     Do not report the presence of local data items (default).
#*
#*   --report-missing-su
#*                     Report measurand data items that are not accompanied by
#*                     the mandatory standard uncertainty values.
#*   --no-report-missing-su, --ignore-missing-su
#*                     Do not report measurand data items that are not
#*                     accompanied by the mandatory standard uncertainty
#*                     values (default).
#*
#*   --continue-on-errors
#*                     Do not terminate script if errors are raised (default).
#*   --die-on-errors
#*                     Terminate script immediately if errors are raised.
#*   --continue-on-warnings
#*                     Do not terminate script if warnings are raised (default).
#*   --die-on-warnings
#*                     Terminate script immediately if warnings are raised.
#*   --continue-on-notes
#*                     Do not terminate script if notes are raised (default).
#*   --die-on-notes
#*                     Terminate script immediately if notes are raised.
#*
#*   --help, --usage
#*                     Output a short usage message (this message) and exit.
#*   --version
#*                     Output version information and exit.
#**
@ARGV = getOptions(
    '-d,--dictionaries'    => sub{ @dict_files = split m/,|\s+/, get_value() },
    '-D,--add-dictionary'  => sub{ push @dict_files, get_value() },
    '--clear-dictionaries' => sub{ @dict_files = () },

    '--treat-as-set'    => sub{ push @{$enum_as_set_tags}, get_value() },
    '--no-treat-as-set' => sub{ $enum_as_set_tags = [] },

    '--verbose'    => sub{ $verbose = 1 },
    '--no-verbose' => sub{ $verbose = 0 },

    '--report-deprecated' => sub{ $report_deprecated = 1 },
    '--ignore-deprecated' => sub{ $report_deprecated = 0 },

    '--report-local-tags'    => sub{ $report_local_tags = 1 },
    '--no-report-local-tags' => sub{ $report_local_tags = 0 },
    '--ignore-local-tags'    => sub{ $report_local_tags = 0 },

    '--report-missing-su'    => sub{ $report_missing_su = 1 },
    '--no-report-missing-su' => sub{ $report_missing_su = 0 },
    '--ignore-missing-su'    => sub{ $report_missing_su = 0 },

    '--continue-on-errors' => sub { $die_on_errors = 0 },
    '--die-on-errors'      => sub { $die_on_errors = 1 },

    '--continue-on-warnings' => sub { $die_on_warnings = 0 },
    '--die-on-warnings'      => sub { $die_on_warnings = 1 },

    '--continue-on-notes'    => sub { $die_on_notes = 0 },
    '--die-on-notes'         => sub { $die_on_notes = 1 },

    '--options'         => sub{ options; exit },
    '--help,--usage'    => sub{ usage; exit },
    '--version'         => sub { print 'cod-tools version ',
                                 $COD::ToolsVersion::Version, "\n";
                                 exit }
);

my $die_on_error_level = {
    'ERROR'   => $die_on_errors,
    'WARNING' => $die_on_warnings,
    'NOTE'    => $die_on_notes
};

if ( !@dict_files ) {
    report_message( {
        'program'   => $0,
        'err_level' => 'ERROR',
        'message'   => 'at least one dictionary file should be provided by '
                     . 'using the \'--dictionaries\' option. Automatic '
                     . 'dictionary download is not implemeted yet'
    }, {
        'ERROR' => 1
    } );
    my $dict_iucr_uri = 'ftp://ftp.iucr.org/pub/cif_core.dic';
}

my $options = { 'parser' => $use_parser, 'no_print' => 1 };
my %dics;
foreach my $dic ( @dict_files ) {
    # TODO: the path should also be constructed from the command line
    # arguments as well as a command line variable
    my $dic_block = parse_ddlm_dic( $dic, {
            'cif_parse_options'  => $options,
            'die_on_error_level' => $die_on_error_level,
        } );

    {
        local $SIG{__WARN__} = sub { process_warnings( {
                         'message'       => @_,
                         'program'       => $0,
                         'filename'      => $dic,
                       }, $die_on_error_level ) };
        $dics{$dic}  = build_search_struct( $dic_block );
    }
};

#for my $name ( sort keys %dicts ) {
#    my $dict = $dicts{$name};
#
#    local $SIG{__WARN__} = sub { process_warnings( {
#                                   'message'       => @_,
#                                   'program'       => $0,
#                                 }, $die_on_error_level ) };
#
#    for my $save_block ( @{$dict->{'Datablock'}{'save_blocks'}} ) {
#        if ( lc get_definition_class 'head' ) {
#            next;
#        }
#        my $category_id = get_category_id( $save_block );
#        my $category = $dict->{'Category'}{lc $category_id};
#
#        # This should not happen in a proper dictionary
#        if ( !defined $category ) {
#            warn "the definition of the '$save_block->{'values'}{'_definition.id'}[0]' " .
#                "data item seems to be incorrect in the '$dict->{'Datablock'}{'name'}' " .
#                "dictionary -- the item is defined as belonging to the " .
#                 "'$category_id' category which is not provided in the " .
#                 "given dictionary\n";
#                next;
#            }
#    }
#}

@ARGV = ('-') unless @ARGV;

my $validation_options = {
    'report_deprecated' => $report_deprecated,
    'report_missing_su' => $report_missing_su,
    'enum_as_set_tags'  => $enum_as_set_tags,
    'verbose'           => $verbose
};

my $err_level = 'NOTE';
for my $filename ( @ARGV ) {
    my $options = { 'parser' => $use_parser, 'no_print' => 1 };
    my ( $data, $err_count, $messages ) = parse_cif( $filename, $options );
    process_parser_messages( $messages, $die_on_error_level );
    my (undef, $dirs, undef) = fileparse($filename);

    for my $data_block ( @{$data} ) {
      my $dataname = 'data_' . $data_block->{'name'};

      # TODO: the path should also be constructed from the command line
      # arguments as well as a command line variable
      my $imported_data = get_imported_files( $data_block, {
                           'file_path'          => [ './', $dirs ],
                           'parser_options'     => $options,
                           'die_on_error_level' => $die_on_error_level,
                           'importing_file'     => $filename,
                         } );

      local $SIG{__WARN__} = sub { process_warnings( {
                                     'message'       => @_,
                                     'program'       => $0,
                                     'filename'      => $filename,
                                     'add_pos'       => $dataname
                                   }, $die_on_error_level ) };

      $data_block = merge_imported_files( $data_block, $imported_data, $die_on_error_level );

      my @validation_messages;
      for my $name ( sort keys %dics ) {
         my $dic = $dics{$name};

        for ( @{ ddlm_validate_data_block( $data_block, $dic, $validation_options ) } ) {
            push @validation_messages,
                sprint_message(
                    $0,
                    $filename,
                    'data_' . $_->{'data_block_code'} .
                        (
                          defined $_->{'save_frame_code'} ?
                          " save_$_->{'save_frame_code'}" :
                          ''
                        ),
                    $err_level,
                    $_->{'message'},
                    undef
                )
        }
      }

      push @validation_messages,
          map {
            sprint_message( $0, $filename, $dataname, $err_level, $_, undef )
          } @{report_unrecognised_data_names( $data_block, \%dics, $report_local_tags )};

      print $_ for (sort @validation_messages);
    }
}

sub parse_ddlm_dic
{
    my ( $dic_name, $options ) = @_;

    my $parser_options     = $options->{'cif_parse_options'};
    my $die_on_error_level = $options->{'die_on_error_level'};

    my ( $data, $err_count, $messages ) = parse_cif( $dic_name, $parser_options );
    process_parser_messages( $messages, $die_on_error_level );
    # TODO: warn if there are more than 1 data block in a file?
    my $dic_block = $data->[0];
    my ($filename, $dirs, $suffix) = fileparse( $dic_name );

    my $imported_data = get_imported_files(
                    $dic_block, {
                       'file_path'          => [ './', $dirs ],
                       'parser_options'     => $parser_options,
                       'die_on_error_level' => $die_on_error_level,
                       'importing_file'     => $dic_name,
                     } );

    $dic_block = merge_imported_files( $dic_block, $imported_data, $die_on_error_level );

    return $dic_block;
}

# TODO: it should also be checked if the category
# that a local dictionary is assigned to actually exists.
sub report_unrecognised_data_names
{
    my ($data_frame, $dicts, $report_local_tags) = @_;

    my @validation_messages;

    my @tags = @{get_data_names($data_frame)};
    if ( !$report_local_tags ) {
        @tags = grep { !is_local_data_name($_) } @tags;
    }

    for my $dict ( values %{$dicts} ) {
        @tags = grep { !exists $dict->{'Item'}{lc $_} } @tags;
    }

    @validation_messages = map {
              "definition of the '$_' data item was not found in " .
              'the provided dictionaries';
          } @tags;

    return \@validation_messages;
}

sub get_data_names
{
    my ( $data_block ) = @_;

    my @data_names;

    push @data_names, @{$data_block->{'tags'}};
    for my $save_block ( @{$data_block->{'save_blocks'}} ) {
        push @data_names, @{$save_block->{'tags'}};
    };

    @data_names = uniq sort map { lc } @data_names;

    return \@data_names;
}
