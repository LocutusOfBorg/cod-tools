#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#  Check dictionaries written in DDLm against the specified instance of
#  the DDLm dictionary.
#**

use strict;
use warnings;

use COD::CIF::Parser qw( parse_cif );
use COD::SOptions qw( getOptions get_value );
use COD::SUsage qw( usage options );
use COD::ErrorHandler qw( process_warnings
                          process_parser_messages
                          report_message );
use File::Basename;

my $use_parser = 'c';
my $ddlm_dictionary;

my $die_on_errors   = 1;
my $die_on_warnings = 0;
my $die_on_notes    = 0;

@ARGV = getOptions(
    '-d,--DDLm-dictionary' => sub { $ddlm_dictionary = get_value() },
    '--options'         => sub{ options; exit },
    '--help,--usage'    => sub{ usage; exit; },

    '--continue-on-errors'          => sub { $die_on_errors = 0 },
    '--die-on-errors'               => sub { $die_on_errors = 1 },

    '--continue-on-warnings' => sub { $die_on_warnings = 0 },
    '--die-on-warnings'      => sub { $die_on_warnings = 1 },

    '--continue-on-notes'    => sub { $die_on_notes = 0 },
    '--die-on-notes'         => sub { $die_on_notes = 1 },
);

my $die_on_error_level = {
    ERROR   => $die_on_errors,
    WARNING => $die_on_warnings,
    NOTE    => $die_on_notes
};

# Default DDLm data item values that might be needed while validating
# CIF files against CIF dictionaries
my %default_ddlm_values = (
    # DDLm version 3.11.10
    '_type.container' => 'Single'
);

my $options = { 'parser' => $use_parser, 'no_print' => 1 };
my ( $data, $err_count, $messages ) = parse_cif( $ddlm_dictionary, $options );
# TODO: warn if there are more than 1 datablock in a file
process_parser_messages( $messages, $die_on_error_level );

my $dict_block = $data->[0];

my($filename, $dirs, $suffix) = fileparse($ddlm_dictionary);

my $imported_data = get_imported_files(
    {
        'container_file' => $dict_block,
        # TODO: the path should also be constructed from the command line
        # arguments as well as a command line variable
        'file_path'      => [ './', $dirs ],
        'imported_files' => {},
        'parser_options' => $options
    }
);

$dict_block = merge_imported_files( $dict_block, $imported_data );

my $validation_dict = build_dictionary($dict_block);

@ARGV = ('-') unless @ARGV;
# start-iterate-through-CIF-files
for my $filename ( @ARGV ) {
    my $options = { 'parser' => $use_parser, 'no_print' => 1 };
    my ( $data, $err_count, $messages ) = parse_cif( $filename, $options );
    process_parser_messages( $messages, $die_on_error_level );

    # TODO: complain if there if more than one data block
    for my $datablock ( @{$data} ) {
      my $dataname = 'data_' . $datablock->{'name'} if defined $datablock->{'name'};
      local $SIG{__WARN__} = sub { process_warnings( {
                                     'message'       => @_,
                                     'program'       => $0,
                                     'filename'      => $filename,
                                     'add_pos'       => $dataname
                                   }, $die_on_error_level ) };

        my $imported_data = get_imported_files(
            {
            'container_file' => $datablock,
            # TODO: the path should also be constructed from the command line
            # arguments as well as a command line variable
            'file_path'      => [ './', $dirs ],
            'imported_files' => {},
            'parser_options' => $options
            }
        );

      $datablock = merge_imported_files( $datablock, $imported_data );

      my $dict = build_dictionary($datablock);

      # TODO: the validation structure should be constructed only once
      # instead of passing it repeatedly for each file
      if ( exists $validation_dict->{'Datablock'}
                  {'values'}{'_dictionary_valid.application'} ) {
        validate_scope_restrictions($dict, $validation_dict);
        validate_type_container($dict, $validation_dict);
      }

      validate_enumerators($dict, $validation_dict);
      validate_type_contents($dict, $validation_dict);
    }
}


#
# This field should probably be parsed by a proper grammar
#
sub parse_multiple_container
{
    my ($container) = @_;

    if ( $container =~ /^List(.*)$/ ) {
        #print $container . "\n";
    }

    return;
}

sub validate_type_contents
{
    my ($dict, $validation_dict) = @_;
    for my $scope ( 'Dictionary', 'Category', 'Item' ) {
    for my $instance ( keys %{$dict->{$scope}} ) {
    for my $tag ( @{$dict->{$scope}{$instance}{'tags'}} ) {
        if ( exists $validation_dict->{'Item'}{$tag} ) {
            my $validation_item = $validation_dict->{'Item'}{$tag};
            if ( exists $validation_item->{'values'}{'_type.contents'} ) {
                my $type_contents = $validation_item->{'values'}{'_type.contents'}[0];
                foreach my $value ( @{$dict->{$scope}{$instance}{'values'}{$tag}} ) {
                    # TODO: implement type content checking for data items
                    # within containers
                    my $message_prefix = "data item '$tag' value '$value' " .
                        "violates content type contraints";

                    if ( ref $value eq '' ) {
                         my $results = check_data_type( $value, $type_contents );
                         print map { $message_prefix . ' - ' . $_ . ".\n" } @$results;
                    } elsif ( ref $value eq 'ARRAY' ) {
                        foreach( @$value ) {
                            $message_prefix = "data item '$tag' value '$_' " .
                                "violates content type contraints";
                            my $results = check_data_type( $_, $type_contents );
                            print map { $message_prefix . ' - ' . $_ . ".\n" } @$results;
                        };
                    } else {
                        print "I am a complex value: '" , ref $value, "'\n";
                        next;
                    }
                }
            }
        }
    }
    }
    }

    return;
}

sub check_data_type
{

# STAR characters according to 10.1021/ci300074v
# (Extensions to the STAR File Syntax, 2012) and its
# EBNF grammar in the supplementary material
my $star_character =
 '\x{0009}' . '\x{000A}' . '\x{000D}' . '\x{0020}-\x{D7FF}' .
 '\x{E000}-\x{FFFD}' . '\x{10000}-\x{10FFF}';

# CIF2 characters according to the EBNF grammar:
# https://www.iucr.org/__data/assets/text_file/0009/112131/CIF2-ENBF.txt
#
# U+0009, U+000A, U+000D, U+0020-U+007E, U+00A0-U+D7FF, U+E000-U+FDCF,
# U+FDF0-U+FFFD, U+10000-U+1FFFD, U+20000-U+2FFFD, U+30000-U+3FFFD,
# U+40000-U+4FFFD, U+50000-U+5FFFD, U+60000-U+6FFFD, U+70000-U+7FFFD,
# U+80000-U+8FFFD, U+90000-U+9FFFD, U+A0000-U+AFFFD, U+B0000-U+BFFFD,
# U+C0000-U+CFFFD, U+D0000-U+DFFFD, U+E0000-U+EFFFD, U+F0000-U+FFFFD,
# U+100000-U+10FFFD
my $cif2_ws_character = '\x{0009}' . '\x{000A}' . '\x{000D}' . '\x{0020}';
my $cif2_nws_character = '\x{0021}-\x{007E}' . '\x{00A0}-\x{D7FF}' .
 '\x{E000}-\x{FDCF}' . '\x{FDF0}-\x{FFFD}' . '\x{10000}-\x{1FFFD}' .
 '\x{20000}-\x{2FFFD}' . '\x{30000}-\x{3FFFD}' . '\x{40000}-\x{4FFFD}' .
 '\x{50000}-\x{5FFFD}' . '\x{60000}-\x{6FFFD}' . '\x{70000}-\x{7FFFD}' .
 '\x{80000}-\x{8FFFD}' . '\x{90000}-\x{9FFFD}' . '\x{A0000}-\x{AFFFD}' .
 '\x{B0000}-\x{BFFFD}' . '\x{C0000}-\x{CFFFD}' . '\x{D0000}-\x{DFFFD}' .
 '\x{E0000}-\x{EFFFD}' . '\x{F0000}-\x{FFFFD}' . '\x{100000}-\x{10FFFD}';

my $signed_float =
    '(?:[-+]?' .
    '(?:[0-9]+(?:\.[0-9]*)?|\.[0-9]+)' .
    '(?:[eE][-+]?[0-9]+)?)';

my $cif2_character = $cif2_ws_character . $cif2_nws_character;

    my ($value, $type) = @_;

    $type = lc $type;
    my @validation_messages;

    if ( $type eq 'text' ) {
        # case-sens strings or lines of STAR characters
        if ( $value =~ m/([^$cif2_character])/ ) {
            push @validation_messages,
                 "the '$1' symbol does not belong to the permitted symbol set";
        }
    } elsif ( $type eq 'code' ) {
        # case-insens contig. string of STAR characters
        if ( $value =~ m/([^$cif2_nws_character])/ ) {
            push @validation_messages,
                "the '$1' symbol does not belong to the permitted symbol set";
        }
    } elsif ( $type eq 'name' ) {
        # case-insens contig. string of alpha-num chars or underscore
        if ( $value =~ m/([^_A-Za-z0-9])/ ) {
            push @validation_messages,
                "the '$1' symbol does not belong to the permitted symbol set";
        }
    } elsif ( $type eq 'tag' ) {
        # case-insens contig. STAR string with leading underscore
        if ( $value !~ m/^_/ ) {
            push @validation_messages,
                "the value must start with an underscore ('_') symbol";
        }
        if ( $value =~ m/([^$cif2_nws_character])/ ) {
            push @validation_messages,
                 "the '$1' symbol does not belong to the permitted symbol set";
        }
    } elsif ( $type eq 'file' ) {
        # TODO: implement File name check
    } elsif ( $type eq 'uri' ) {
        # TODO: implement Uri check
    } elsif ( $type eq 'date' ) {
        # ISO standard date format <yyyy>-<mm>-<dd>
        if ( $value !~ m/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/ ) {
            push @validation_messages,
                 'the value should conform to the ISO standard date format ' .
                 '<yyyy>-<mm>-<dd>';
        }
    } elsif ( $type eq 'version' ) {
        # version digit string of the form <major>.<version>.<update>
        if ( $value !~ m/^[0-9]+(\.[0-9]+)?(\.[0-9]+)?$/ ) {
            push @validation_messages,
                 'the value should be a version digit string of the form ' .
                 '<major>.<version>.<update>';
        }
    } elsif ( $type eq 'dimension' ) {
        # integer limits of an Array/Matrix/List in square brackets
    } elsif ( $type eq 'range' ) {
        # inclusive range of numerical values min:max
    } elsif ( $type eq 'count' ) {
        # unsigned integer number
        if ( $value !~ m/^[0-9]*$/ ) {
            push @validation_messages,
                 'the value should be an unsigned integer number';
        }
    } elsif ( $type eq 'index' ) {
        # unsigned non-zero integer number
        if ( $value !~ m/^[0-9]*[1-9]$/ ) {
            push @validation_messages,
                 'the value should be an unsigned non-zero integer number';
        }
    } elsif ( $type eq 'integer' ) {
        # positive or negative integer number
        if ( $value !~ m/^[-+]?[0-9]*$/ ) {
            push @validation_messages,
                 'the value should be an integer number';
        }
    } elsif ( $type eq 'real' ) {
        # floating-point real number
        if ( $value !~ m/^$signed_float$/ ) {
            push @validation_messages,
                 'the value should be a floating-point real number';
        }
    } elsif ( $type eq 'imag' ) {
        # floating-point imaginary number
        if ( $value !~ m/^${signed_float}i$/ ) {
            push @validation_messages,
                 'the value should be a floating-point imaginary number';
        }
    } elsif ( $type eq 'complex' ) {
        # complex number <R>+j<I>
    } elsif ( $type eq 'binary' ) {
        # binary number \b<N>
        if ( $value !~ m/^[01]+$/ ) {
            push @validation_messages,
                 'the value should be a floating-point real number';
        }
    } elsif ( $type eq 'hexadecimal' ) {
        # hexadecimal number \x<N>
        if ( $value !~ m/^[0-9A-Fa-f]+$/ ) {
            push @validation_messages,
                 'the value should be an hexadecimal number';
        }
    } elsif ( $type eq 'octal' ) {
        # octal number \o<N>
        if ( $value !~ m/^[0-7]+$/ ) {
            push @validation_messages,
                 'the value should be an octal number';
        }
    } elsif ( $type eq 'implied' ) {
        # implied by the context of the attribute
    } elsif ( $type eq 'byreference' ) {
        # The contents have the same form as those of the attribute referenced by
        #        _type.contents_referenced_id.
    } else {
        warn "content type '$type' is not recognised\n";
    }

    return \@validation_messages;
}

sub validate_type_container
{
    my ($dict, $validation_dict) = @_;
    for my $scope ( 'Dictionary', 'Category', 'Item' ) {
    for my $instance ( keys %{$dict->{$scope}} ) {
    for my $tag ( @{$dict->{$scope}{$instance}{'tags'}} ) {
        if ( exists $validation_dict->{'Item'}{$tag} ) {
            my $validation_item = $validation_dict->{'Item'}{$tag};
            if ( exists $validation_item->{'values'}{'_type.container'} ) {
                my $type_container = $validation_item->{'values'}{'_type.container'}[0];
                my $value = $dict->{$scope}{$instance}{'values'}{$tag}[0];
                if ( lc $type_container eq lc 'Single' ) {
                    if ( ref $value ne '' ) {
                        warn "data item '$tag' value must not have a top level " .
                             "container\n";
                    }
                } elsif ( lc $type_container eq lc 'Multiple' ) {
                    # TODO: implement Multiple type check
                } elsif ( lc $type_container eq lc 'Array' ) {
                    # TODO: implement Array type check
                } elsif ( lc $type_container eq lc 'Matrix') {
                    # TODO: implement Matrix type check
                } elsif ( lc $type_container eq lc 'List' ) {
                    if ( ref $value ne 'ARRAY' ) {
                        warn "data item '$tag' value must have a top level " .
                             "list container ([v1 v2 ...])\n";
                    };
                } elsif ( lc $type_container eq lc 'Table' ) {
                    if ( ref $value ne 'HASH' ) {
                        warn "data item '$tag' value must have a top level " .
                             "table container ([v1 v2 ...])\n";
                    };
                }
            }
        }
    }
    }
    }

    return;
}

sub validate_enumerators
{
    my ($dict, $validation_dict) = @_;

    for my $scope ( 'Dictionary', 'Category', 'Item' ) {
      for my $instance ( keys %{$dict->{$scope}} ) {
        for my $tag ( @{$dict->{$scope}{$instance}{'tags'}} ) {
          if ( exists $validation_dict->{'Item'}{$tag} ) {
            my $validation_item = $validation_dict->{'Item'}{$tag};
            if ( exists $validation_item->{'values'}{'_enumeration_set.state'} ) {
                my @enumeration_values = @{
                                $validation_item->{'values'}
                                {'_enumeration_set.state'} };
                my $type_container = $default_ddlm_values{'_type.container'};
                if ( exists $validation_item->{'values'}{'_type.container'}) {
                    $type_container = $validation_item->{'values'}{'_type.container'}[0];
                }

                my $value = $dict->{$scope}{$instance}{'values'}{$tag}[0];
                if ( lc $type_container eq lc 'Single' ) {
                    if (! grep { lc $value eq lc $_ } @enumeration_values ) {
                    #  print "$instance: $tag: $value is not permitted\n";
                    warn "data item '$tag' value \"$value\" "
                         . 'must be one of the enumeration values '
                         . '[' . ( join ', ', @enumeration_values ) . ']' . "\n";
                    }
                # Mainly targeted at '_type.contents'
                } elsif ( lc $type_container eq lc 'Multiple' ) {
                    if (! grep { lc $value eq lc $_ } @enumeration_values ) {
                 #     print "$instance: $tag: $value is not permitted\n";
                  #  warn "data item '$tag' value \"$value\" "
                  #     . 'must be one of the enumeration values '
                  #     . '[' . ( join ', ', @enumeration_values ) . ']. '
                  #     . 'This message might be a false positive since '
                  #     . 'handling of enumeration values with the ' 
                  #     . "'Multiple' type container is not yet implemented\n";
                        parse_multiple_container($value);
                    }
                # TODO: consider all of these combinations?
                # even if they don't really occur?
                } elsif ( lc $type_container eq lc 'Array' ) {

                } elsif ( lc $type_container eq lc 'Matrix') {

                } elsif ( lc $type_container eq lc 'List' ) {

                } elsif ( lc $type_container eq lc 'Table' ) {

                }
            }
          }
        }
      }
    }

    return;
}

# TODO: maybe this subroutine should return an array of error messages?
# instead of printing directly to STDERR?
sub validate_scope_restrictions
{
    my ($dict, $validation_dict) = @_;

      my %dict_restrictions;
      my $valid_application = $validation_dict->{'Datablock'}
                              {'values'}{'_dictionary_valid.application'};
      my $valid_attributes  = $validation_dict->{'Datablock'}
                              {'values'}{'_dictionary_valid.attributes'};
      for (my $i = 0; $i < @{$valid_application}; $i++) {
          $dict_restrictions
            {$valid_application->[$i][0]}
            {$valid_application->[$i][1]} = $valid_attributes->[$i]
      };
      # expand valid attribute categories into individual data item names
      foreach my $scope (keys %dict_restrictions) {
        foreach my $option ( keys %{$dict_restrictions{$scope}} ) {
            $dict_restrictions{$scope}{$option} =
                expand_categories($dict_restrictions{$scope}{$option},
                                  $validation_dict);
        }
      }

      for my $scope ( 'Dictionary', 'Category', 'Item' ) {
        for my $instance ( keys %{$dict->{$scope}} ) {
          my %mandatory   = map { $_ => 0 } @{$dict_restrictions{$scope}{'Mandatory'}};
          my %recommended = map { $_ => 0 } @{$dict_restrictions{$scope}{'Recommended'}};
          my %prohibited  = map { $_ => 0 } @{$dict_restrictions{$scope}{'Prohibited'}};
          for my $tag ( @{$dict->{$scope}{$instance}{'tags'}} ) {
              if ( exists $prohibited{$tag} ) {
                warn "data item '$tag' is prohibited in the '$scope' scope of " .
                     "the $instance frame\n";
              }
              $mandatory{$tag}   = 1 if ( exists $mandatory{$tag} );
              $recommended{$tag} = 1 if ( exists $recommended{$tag} );
          }
          foreach my $tag (keys %mandatory) {
            if ( $mandatory{$tag} == 0 ) {
                warn "data item '$tag' is mandatory in the '$scope' scope of " .
                     "the $instance frame\n"
            }
          }
          foreach my $tag (keys %recommended) {
            if ( $recommended{$tag} == 0 ) {
        #        warn "data item '$tag' is recommended in the '$scope' scope of " .
        #             "the $instance frame\n"
            }
          }
        }
      }

    return;
}

sub build_dictionary
{
    my ($data) = @_;

    my %categories;
    my %items;
    for my $saveblock ( @{$data->{'save_blocks'}} ) {
        my $values = $saveblock->{values};

        if ( exists $values->{'_definition.scope'} ) {
            if ( $values->{'_definition.scope'}[0] eq 'Dictionary' ) {
                next; #
            } elsif ( $values->{'_definition.scope'}[0] eq 'Category' ) {
                $categories{ $values->{'_definition.id'}[0] } = $saveblock;
            } elsif ( $values->{'_definition.scope'}[0] eq 'Item' ) {
                $items{ $values->{'_definition.id'}[0] } = $saveblock;
            } else {
                # this error should be reported by the enumeration check
            }
        } else {
            # ITEM is currently stated as the default value
            $items{ $values->{'_definition.id'}[0] } = $saveblock;
        }
    };

    my $dictionary = {
        'Dictionary' => { $data->{'name'} => $data },
        'Category'   => \%categories,
        'Item'       => \%items,
        'Datablock'  => $data
    };

    return $dictionary;
}

#
# dictionary = {
#   'file_path'       => [ 'dir1', 'dir2', 'dir3' ]
#   'container_file' =>
#   'imported_files'  =>
#   'parser_options'  =>
# }
#
# TODO: consider a more conservative dictionary import system
#
sub get_imported_files
{
    my ($params) = @_;
    my $file_path = $params->{'file_path'};
    my $container_file = $params->{'container_file'};
    my %imported_files = %{$params->{'imported_files'}};
    my $parser_options = $params->{'parser_options'};

    for my $saveblock ( @{$container_file->{'save_blocks'}} ) {
      if ( exists $saveblock->{'values'}{'_import.get'} &&
           exists $saveblock->{'values'}{'_import.get'}[0] ) {
        foreach my $import ( @{$saveblock->{'values'}{'_import.get'}[0]} ) {
          my $filename = $import->{'file'};
          if ( !exists $imported_files{$filename} ) {
            foreach my $path ( @{$file_path} ) {
              # TODO: the path ends up with a double slash
              if ( -f "$path/$filename" ) {
                my ( $import_data, $err_count, $messages ) =
                  parse_cif( "$path/$filename", $parser_options );
                # TODO: check how the error messages interact with the
                # subroutine context
                process_parser_messages( $messages, $die_on_error_level );
                $imported_files{$filename} = $import_data->[0];
                my $single_import = get_imported_files( {
                    'file_path'      => $file_path,
                    'container_file' => $import_data->[0],
                    'imported_files' => \%imported_files,
                    'parser_options' => $parser_options
                } );
                %imported_files = %{$single_import};
                last;
              }
            }
          }
        }
      }
    }

    return \%imported_files;
}

# TODO: check for cyclic relationships
sub merge_imported_files
{
    my ($dict, $imported_files) = @_;

    for my $saveblock ( @{$dict->{'save_blocks'}} ) {
      if ( exists $saveblock->{'values'}{'_import.get'} &&
           exists $saveblock->{'values'}{'_import.get'}[0] ) {
        foreach my $import ( @{$saveblock->{'values'}{'_import.get'}[0]} ) {
          my $filename = $import->{'file'};
          if ( exists $imported_files->{$filename} ) {
            my $imported_file = $imported_files->{$filename};
            $imported_file = merge_imported_files($imported_file, $imported_files);


            my $target_saveblock = $import->{'save'};
            foreach my $imported_saveblock ( @{$imported_file->{'save_blocks'}} ) {
              # TODO: check for case-sensitivity
              if ( $imported_saveblock->{'name'} eq $target_saveblock ) {
                $saveblock = merge_save_blocks($saveblock, $imported_saveblock);
              }
            }
          }
        }
      }
    }

    return $dict;
}

# TODO: rewrite as non-destructive?
sub merge_save_blocks
{
    my ($main_save_block, $auxilary_save_block) = @_;

    foreach my $key ( keys %{$auxilary_save_block->{'types'}} ) {
        $main_save_block->{'types'}{$key} = $auxilary_save_block->{'types'}{$key};
    }

    foreach my $key ( keys %{$auxilary_save_block->{'values'}} ) {
        $main_save_block->{'values'}{$key} = $auxilary_save_block->{'values'}{$key};
    }

    foreach my $key ( keys %{$auxilary_save_block->{'inloop'}} ) {
        $main_save_block->{'inloop'}{$key} =
            $auxilary_save_block->{'inloop'}{$key} +
            scalar @{$main_save_block->{'loops'}};
    }

    push @{$main_save_block->{'loops'}}, @{$auxilary_save_block->{'loops'}};
    push @{$main_save_block->{'tags'}}, @{$auxilary_save_block->{'tags'}};

    return $main_save_block;
}

sub expand_categories
{
    my ($categories, $dict) = @_;

    my @expanded_categories;
    foreach my $category (@{$categories}) {
        if ( exists $dict->{'Item'}{$category} ) {
            push @expanded_categories, $category;
        } elsif ( exists $dict->{'Category'}{$category} ) {
            for my $id (keys %{$dict->{'Item'}}) {
                if ( exists $dict->{'Item'}{$id}{'values'}{'_name.category_id'} &&
                     lc $dict->{'Item'}{$id}{'values'}{'_name.category_id'}[0] eq lc $category ) {
                    push @expanded_categories, $id;
                }
            }
            for my $id (keys %{$dict->{'Category'}}) {
                if ( exists $dict->{'Category'}{$id}{'values'}{'_name.category_id'}[0] &&
                     lc $dict->{'Category'}{$id}{'values'}{'_name.category_id'}[0] eq lc $category ) {
                    push @expanded_categories, @{expand_categories([ $id ], $dict)};
                }
            }
        } else {
          #  print keys %{$dict->{'Item'}};
            print "$category\n";
            die 'No such data item or category was found in dictionary';
        }
    }

    return \@expanded_categories;
}
