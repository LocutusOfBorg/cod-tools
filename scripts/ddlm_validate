#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#* Check dictionaries written in DDLm against the specified instance of
#* the DDLm dictionary.
#*
#* USAGE:
#*    $0 --dictionaries 'cif_core.dic,cif_cod.dic' --options input1.cif input*.cif
#**

use strict;
use warnings;
binmode STDOUT, ':encoding(UTF-8)';
binmode STDERR, ':encoding(UTF-8)';

use List::MoreUtils qw( any );
use File::Basename;
use Scalar::Util qw( looks_like_number );
use URI;

use COD::CIF::Parser qw( parse_cif );
use COD::SOptions qw( getOptions get_value );
use COD::SUsage qw( usage options );
use COD::ErrorHandler qw( process_warnings
                          process_parser_messages
                          report_message );
use COD::ToolsVersion;

my $use_parser = 'c';
my $report_local_tags = 0;
my @dict_files;

my $die_on_errors   = 1;
my $die_on_warnings = 0;
my $die_on_notes    = 0;

#* OPTIONS:
#*   -d, --dictionaries 'cif_core.dic,cif_cod.dic'
#*                     A list of CIF dictionary files (according to DDLm)
#*                     to be used in CIF file validation. List elements
#*                     are separated either by ',' or by ' '. To include
#*                     dictionaries with filenames containing these symbols,
#*                     the --add-dictionary option is used.
#*   -D, --add-dictionary 'cif new dictionary.dic'
#*                     Add additional CIF dictionary to the list.
#*   --clear-dictionaries
#*                     Remove all CIF dictionaries from the list.
#*
#*   --report-local-tags
#*                     Validate data items having tags prefixed with
#*                     the '_[local]' prefix.
#*   --no-report-local-tags, --ignore-local-tags
#*                     Ignore data items having tags prefixed with '_[local]'
#*                     prefix (default).
#*
#*   --continue-on-errors
#*                     Do not terminate script if errors are raised (default).
#*   --die-on-errors
#*                     Terminate script immediately if errors are raised.
#*   --continue-on-warnings
#*                     Do not terminate script if warnings are raised (default).
#*   --die-on-warnings
#*                     Terminate script immediately if warnings are raised.
#*   --continue-on-notes
#*                     Do not terminate script if notes are raised (default).
#*   --die-on-notes
#*                     Terminate script immediately if notes are raised.
#*
#*   --help, --usage
#*                     Output a short usage message (this message) and exit.
#*   --version
#*                     Output version information and exit.
#**
@ARGV = getOptions(
    '-d,--dictionaries'    => sub{ @dict_files = split m/,|\s+/, get_value() },
    '-D,--add-dictionary'  => sub{ push @dict_files, get_value() },
    '--clear-dictionaries' => sub{ @dict_files = () },

    '--report-local-tags'               => sub{ $report_local_tags = 1 },
    '--no-report-local-tags'            => sub{ $report_local_tags = 0 },
    '--ignore-local-tags'               => sub{ $report_local_tags = 0 },

    '--continue-on-errors'          => sub { $die_on_errors = 0 },
    '--die-on-errors'               => sub { $die_on_errors = 1 },

    '--continue-on-warnings' => sub { $die_on_warnings = 0 },
    '--die-on-warnings'      => sub { $die_on_warnings = 1 },

    '--continue-on-notes'    => sub { $die_on_notes = 0 },
    '--die-on-notes'         => sub { $die_on_notes = 1 },

    '--options'         => sub{ options; exit },
    '--help,--usage'    => sub{ usage; exit; },
    '--version'      => sub { print 'cod-tools version ',
                                 $COD::ToolsVersion::Version, "\n";
                                 exit }
);

my $die_on_error_level = {
    ERROR   => $die_on_errors,
    WARNING => $die_on_warnings,
    NOTE    => $die_on_notes
};

# Default DDLm data item values that might be needed while validating
# CIF files against CIF dictionaries
my %default_ddlm_values = (
    # DDLm version 3.11.10
    '_type.container' => 'Single'
);

# TODO: consider the fact that files can have alternative names ('.' vs. '_')

# TODO: implement iteration over the validation dictionaries

my %dicts;
if( @dict_files ) {
    my $options = { 'parser' => $use_parser, 'no_print' => 1 };
    foreach my $dict ( @dict_files ) {
        my ( $data, $err_count, $messages ) = parse_cif( $dict, $options );
        process_parser_messages( $messages, $die_on_error_level );
        # TODO: warn if there are more than 1 data block in a file?
        my $dict_block = $data->[0];
        my($filename, $dirs, $suffix) = fileparse($dict);
        my $imported_data = get_imported_files(
            {
                'container_file' => $dict_block,
                # TODO: the path should also be constructed from the command line
                # arguments as well as a command line variable
                'file_path'      => [ './', $dirs ],
                'imported_files' => {},
                'parser_options' => $options
            }
        );
        $dict_block = merge_imported_files( $dict_block, $imported_data );
        $dicts{$dict} =  build_search_struct( $dict_block );
    }
} else {
    report_message( {
        'program'   => $0,
        'err_level' => 'ERROR',
        'message'   => 'at least one dictionary file should be provided by '
                     . 'using the \'--dictionaries\' option. Automatic '
                     . 'dictionary download is not implemeted yet'
    }, $die_on_errors );
    my $dict_iucr_uri = 'ftp://ftp.iucr.org/pub/cif_core.dic';
};

@ARGV = ('-') unless @ARGV;
# start-iterate-through-CIF-files

for my $filename ( @ARGV ) {
    my $options = { 'parser' => $use_parser, 'no_print' => 1 };
    my ( $data, $err_count, $messages ) = parse_cif( $filename, $options );
    process_parser_messages( $messages, $die_on_error_level );
    my (undef, $dirs, undef) = fileparse($filename);

    # TODO: complain if there if more than one data block
    for my $datablock ( @{$data} ) {
      my $dataname = 'data_' . $datablock->{'name'} if defined $datablock->{'name'};
      local $SIG{__WARN__} = sub { process_warnings( {
                                     'message'       => @_,
                                     'program'       => $0,
                                     'filename'      => $filename,
                                     'add_pos'       => $dataname
                                   }, $die_on_error_level ) };

        my $imported_data = get_imported_files(
            {
            'container_file' => $datablock,
            # TODO: the path should also be constructed from the command line
            # arguments as well as a command line variable
            'file_path'      => [ './', $dirs ],
            'imported_files' => {},
            'parser_options' => $options
            }
        );

      $datablock = merge_imported_files( $datablock, $imported_data );
      my $struct = build_search_struct($datablock);
      my @tags = sort keys %{get_data_names($datablock)};
     # my @tags = @{$datablock->{'tags'}};
     # foreach (@{$datablock->{'saveblocks'}}) {
     #   push @tags, @{$_->{'tags'}}
     # }

      my @validation_messages;
      # TODO: the validation structure should be constructed only once
      # instead of passing it repeatedly for each file

      for my $name ( sort keys %dicts ) {
        my $dict = $dicts{$name};
        if ( exists $dict->{'Datablock'}
                      {'values'}{'_dictionary_valid.application'} ) {
            push @validation_messages,
                 @{validate_scope_restrictions($struct, $dict)};
        }

        push @validation_messages, @{validate_type_contents($struct, $dict)};
        push @validation_messages, @{validate_enumerators($struct, $dict)};
        push @validation_messages, @{validate_range($struct, $dict)};
        push @validation_messages, @{validate_type_container($struct, $dict)};

# check against a range

        # check for the existence of items related by the _name.linked_item_id
        # validate_linked_items($dict, $dict);

        # _name.linked_item_id check existence of the given data item

        # check the matching of _name.linked_item_id linked values (except)

        # check looped/unlooped

        # check for the existence of the key data item

        # eligibility of su values
        # map { "$filename: $dataname: $_.\n" }
        @tags = grep { !exists $dict->{'Tags'}{lc $_} } @tags;
      }

      if ( !$report_local_tags ) {
        @tags = grep { $_ !~ m/^_\[local\]/ } @tags;
      }

      push @validation_messages,
           map {
              "data item '$_' was not found in the provided dictionaries";
            } @tags;

      foreach ( @validation_messages ) {
        warn $_ . "\n";
      }
    }
}

sub validate_linked_items
{
    my ($data, $dict) = @_;

    for my $scope ( 'Dictionary', 'Category', 'Item' ) {
    for my $instance ( keys %{$data->{$scope}} ) {
    for my $tag ( @{$data->{$scope}{$instance}{'tags'}} ) {
        if ( exists $dict->{'Item'}{$tag} ) {
            my $dict_item = $dict->{'Item'}{$tag};
            if ( exists $dict_item->{'values'}{'_name.linked_item_id'} ) {
                my $linked_item = $dict_item->{'values'}{'_name.linked_item_id'}[0];
                # TODO: implement the check
            }
        }
    }
    }
    }

    return;
}

##
# Checks the content type against the DDLm dictionary file.
# @param $data
#       The data structure of the validated dictionary (as returned by the
#       'build_search_struct' data structure).
# @param $dict
#       The data structure of the validation dictionary (as returned by the
#       'build_search_struct' data structure).
# @return
#       Array reference to a list of validation messages.
##
sub validate_type_contents
{
    my ($data, $dict) = @_;

    my @validation_messages;

    for my $scope ( 'Dictionary', 'Category', 'Item' ) {
    for my $instance ( sort keys %{$data->{$scope}} ) {
    for my $tag ( @{$data->{$scope}{$instance}{'tags'}} ) {
      if ( exists $dict->{'Item'}{$tag} ) {
        my $validation_item = $dict->{'Item'}{$tag};
        if ( exists $validation_item->{'values'}{'_type.contents'} ) {
          my $type_contents = lc $validation_item->{'values'}{'_type.contents'}[0];
          # The 'implied' data type points to the data type given in the
          # data item definition save frame
          if ( $type_contents eq 'implied' ) {
              # TODO: maybe the 'implied' values should be replaced with proper
              # data types before calling this subroutine?
              if ( exists $data->{$scope}{$instance}{'values'}{'_type.contents'}[0] ) {
                $type_contents = $data->{$scope}{$instance}{'values'}{'_type.contents'}[0];
              }
          }
          foreach my $value ( @{$data->{$scope}{$instance}{'values'}{$tag}} ) {
            # TODO: implement type content checking for data items
            # within containers

            if ( ref $value eq '' ) {
              my $message_prefix = "data item '$tag' value '$value' " .
                           'violates content type constraints';
              push @validation_messages,
                map { $message_prefix . ' -- ' . $_ }
                  @{ check_data_type( $value, $type_contents ) };
            } elsif ( ref $value eq 'ARRAY' ) {
              foreach( @{$value} ) {
                my $message_prefix = "data item '$tag' value '$_' " .
                             'violates content type constraints';
                push @validation_messages,
                  map { $message_prefix . ' -- ' . $_ }
                    @{ check_data_type( $_, $type_contents ) };
              }
            } else {
                # TODO: implement hash value validation
                warn 'Handling of more complex values is not yet implemented: ',
                     ref $value, "'\n";
                next;
            }
          }
        }
      }
    }}}

    return \@validation_messages;
}

##
# Checks the value against the DDLm data type constraints.
# @param $value
#       The data value that is being validated.
# @param $type
#       The declared data type of the value.
# @return
#       Array reference to a list of validation messages.
##
sub check_data_type
{

# STAR characters according to 10.1021/ci300074v
# (Extensions to the STAR File Syntax, 2012) and its
# EBNF grammar in the supplementary material
my $star_character =
 '\x{0009}' . '\x{000A}' . '\x{000D}' . '\x{0020}-\x{D7FF}' .
 '\x{E000}-\x{FFFD}' . '\x{10000}-\x{10FFF}';

# CIF2 characters according to the EBNF grammar:
# https://www.iucr.org/__data/assets/text_file/0009/112131/CIF2-ENBF.txt
#
# U+0009, U+000A, U+000D, U+0020-U+007E, U+00A0-U+D7FF, U+E000-U+FDCF,
# U+FDF0-U+FFFD, U+10000-U+1FFFD, U+20000-U+2FFFD, U+30000-U+3FFFD,
# U+40000-U+4FFFD, U+50000-U+5FFFD, U+60000-U+6FFFD, U+70000-U+7FFFD,
# U+80000-U+8FFFD, U+90000-U+9FFFD, U+A0000-U+AFFFD, U+B0000-U+BFFFD,
# U+C0000-U+CFFFD, U+D0000-U+DFFFD, U+E0000-U+EFFFD, U+F0000-U+FFFFD,
# U+100000-U+10FFFD
my $cif2_ws_character = '\x{0009}' . '\x{000A}' . '\x{000D}' . '\x{0020}';
my $cif2_nws_character = '\x{0021}-\x{007E}' . '\x{00A0}-\x{D7FF}' .
 '\x{E000}-\x{FDCF}' . '\x{FDF0}-\x{FFFD}' . '\x{10000}-\x{1FFFD}' .
 '\x{20000}-\x{2FFFD}' . '\x{30000}-\x{3FFFD}' . '\x{40000}-\x{4FFFD}' .
 '\x{50000}-\x{5FFFD}' . '\x{60000}-\x{6FFFD}' . '\x{70000}-\x{7FFFD}' .
 '\x{80000}-\x{8FFFD}' . '\x{90000}-\x{9FFFD}' . '\x{A0000}-\x{AFFFD}' .
 '\x{B0000}-\x{BFFFD}' . '\x{C0000}-\x{CFFFD}' . '\x{D0000}-\x{DFFFD}' .
 '\x{E0000}-\x{EFFFD}' . '\x{F0000}-\x{FFFFD}' . '\x{100000}-\x{10FFFD}';

my $signed_float =
    '(?:[-+]?' .
    '(?:[0-9]+(?:\.[0-9]*)?|\.[0-9]+)' .
    '(?:[eE][-+]?[0-9]+)?)';

my $cif2_character = $cif2_ws_character . $cif2_nws_character;

    my ($value, $type) = @_;

    my @validation_messages;

    $type = lc $type;
    if ( $type eq 'text' ) {
        # case-sens strings or lines of STAR characters
        if ( $value =~ m/([^$cif2_character])/ ) {
            push @validation_messages,
                 "the '$1' symbol does not belong to the permitted symbol set";
        }
    } elsif ( $type eq 'code' ) {
        # case-insens contig. string of STAR characters
        if ( $value =~ m/([^$cif2_nws_character])/ ) {
            push @validation_messages,
                "the '$1' symbol does not belong to the permitted symbol set";
        }
    } elsif ( $type eq 'name' ) {
        # case-insens contig. string of alpha-num chars or underscore
        if ( $value =~ m/([^_A-Za-z0-9])/ ) {
            push @validation_messages,
                "the '$1' symbol does not belong to the permitted symbol set";
        }
    } elsif ( $type eq 'tag' ) {
        # case-insens contig. STAR string with leading underscore
        if ( $value !~ m/^_/ ) {
            push @validation_messages,
                'the value must start with an underscore (\'_\') symbol';
        }
        if ( $value =~ m/([^$cif2_nws_character])/ ) {
            push @validation_messages,
                 "the '$1' symbol does not belong to the permitted symbol set";
        }
    } elsif ( $type eq 'file' ) {
        # TODO: implement File name check
        push @validation_messages,
                 "validation of the 'file' type data items is not yet " .
                 'implemented';
    } elsif ( $type eq 'uri' ) {
        # TODO: implement proper URI parsing as per RFC 3986
        use URI::Split qw(uri_split);
        my ($scheme, $auth, $path, $query, $frag) = uri_split($value);
        if (defined $scheme) {
            if ( $scheme =~ /^[^A-Za-z]/ ) {
                push @validation_messages, "the URI scheme component '$scheme' " .
                    'must start with a ASCII letter ([A-Za-z])';
            }
            if ( $scheme =~ /([^A-Za-z0-9.+-])/ ) {
                push @validation_messages, "the '$1' symbol is not allowed " .
                    "in the URI scheme component '$scheme'";
            };
        } else {
            push @validation_messages,
                 'an URI string must start with a scheme component';
        }
    } elsif ( $type eq 'date' ) {
        # ISO standard date format <yyyy>-<mm>-<dd>
        if ( $value !~ m/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/ ) {
            push @validation_messages,
                 'the value should conform to the ISO standard date format ' .
                 '<yyyy>-<mm>-<dd>';
        }
        # TODO: a more thorough check should be carried out for the dates --
        #       the month and day values ranges should be checked
    } elsif ( $type eq 'version' ) {
        # version digit string of the form <major>.<version>.<update>
        if ( $value !~ m/^[0-9]+(?:\.[0-9]+){0,2}$/ ) {
            push @validation_messages,
                 'the value should be a version digit string of the form ' .
                 '<major>.<version>.<update>';
        }
    } elsif ( $type eq 'dimension' ) {
        # integer limits of an Array/Matrix/List in square brackets
        push @validation_messages,
                 'validation of the \'dimension\' type data items is not yet ' .
                 'implemented';
    } elsif ( $type eq 'range' ) {
        # inclusive range of numerical values min:max
        # TODO: are letters allowed in ranges?
        $value =~ m/^(${signed_float})?:(${signed_float})?$/;
        if ( !defined $1 && !defined $2 ) {
            push @validation_messages,
                 'the value should be a range of numerical values of ' .
                 'the form \'min:max\'';
        } elsif ( defined $1 && defined $2 ) {
            if ( $1 > $2 ) {
                push @validation_messages,
                    "the lower range value '$1' is greater than the upper " .
                    "range value '$2'";
            }
        }
       # push @validation_messages,
       #          "validation of the 'range' type data items is not yet " .
       #         'implemented';
    } elsif ( $type eq 'count' ) {
        # unsigned integer number
        if ( $value !~ m/^[0-9]*$/ ) {
            push @validation_messages,
                 'the value should be an unsigned integer';
        }
    } elsif ( $type eq 'index' ) {
        # unsigned non-zero integer
        $value =~ s/\([0-9]*\)$//;
        if ( $value =~ m/[^0-9]/ || !( $value =~ m/^[0-9]*$/ && $value > 0 ) ) {
            push @validation_messages,
                 'the value should be an unsigned non-zero integer';
        }
    } elsif ( $type eq 'integer' ) {
        # positive or negative integer
        $value =~ s/\([0-9]*\)$//;
        if ( $value !~ m/^[-+]?[0-9]*$/ ) {
            push @validation_messages,
                 'the value should be an integer';
        }
    } elsif ( $type eq 'real' ) {
        # floating-point real number
        $value =~ s/\([0-9]*\)$//;
        if ( $value !~ m/^$signed_float$/ ) {
            push @validation_messages,
                 'the value should be a floating-point real number';
        }
    } elsif ( $type eq 'imag' ) {
        # floating-point imaginary number
        #if ( $value !~ m/^${signed_float}i$/ ) {
        #    push @validation_messages,
        #         'the value should be a floating-point imaginary number';
        #}
        push @validation_messages,
                 'validation of the \'imag\' type data items is not yet ' .
                 'implemented';
    } elsif ( $type eq 'complex' ) {
        # complex number <R>+j<I>
        #push @validation_messages,
        #         'validation of the \'complex\' type data items is not yet ' .
        #         'implemented';
        push @validation_messages,
                 'validation of the \'complex\' type data items is not yet ' .
                 'implemented';
    } elsif ( $type eq 'binary' ) {
        # binary number \b<N>
        #if ( $value !~ m/^[01]+$/ ) {
        #    push @validation_messages,
        #        'the value should be a floating-point real number';
        #}
        push @validation_messages,
                 'validation of the \'binary\' type data items is not yet ' .
                 'implemented';
    } elsif ( $type eq 'hexadecimal' ) {
        # hexadecimal number \x<N>
        #if ( $value !~ m/^[0-9A-Fa-f]+$/ ) {
        #    push @validation_messages,
        #         'the value should be an hexadecimal number';
        #}
        push @validation_messages,
                 'validation of the \'hexadecimal\' type data items is not yet ' .
                 'implemented';
    } elsif ( $type eq 'octal' ) {
        # octal number \o<N>
        #if ( $value !~ m/^[0-7]+$/ ) {
        #    push @validation_messages,
        #         'the value should be an octal number';
        #}
        push @validation_messages,
                 'validation of the \'octal\' type data items is not yet ' .
                 'implemented';
    } elsif ( $type eq 'implied' ) {
        # implied by the context of the attribute
        push @validation_messages,
                 'validation of the \'implied\' type data items is not yet ' .
                 'implemented';
    } elsif ( $type eq 'byreference' ) {
        # The contents have the same form as those of the attribute referenced by
        #        _type.contents_referenced_id.
        push @validation_messages,
                 'validation of the \'byreference\' type data items is not yet ' .
                 'implemented';
    } else {
        warn "content type '$type' is not recognised\n";
    }

    return \@validation_messages;
}

##
# Checks the container types against the DDLm dictionary file.
# @param $data
#       The data structure of the validated dictionary (as returned by the
#       'build_search_struct' data structure).
# @param $dict
#       The data structure of the validation dictionary (as returned by the
#       'build_search_struct' data structure).
# @return
#       Array reference to a list of validation messages.
##
sub validate_type_container
{
    my ($data, $dict) = @_;

    my @validation_messages;

    for my $scope ( 'Dictionary', 'Category', 'Item' ) {
    for my $instance ( keys %{$data->{$scope}} ) {
    for my $tag ( @{$data->{$scope}{$instance}{'tags'}} ) {
      if ( exists $dict->{'Item'}{$tag} ) {
        my $validation_item = $dict->{'Item'}{$tag};
          if ( exists $validation_item->{'values'}{'_type.container'} ) {
            my $type_container = lc $validation_item->{'values'}{'_type.container'}[0];
            my $value = $data->{$scope}{$instance}{'values'}{$tag}[0];
            if ( $type_container eq 'single' ) {
              if ( ref $value ne '' ) {
                   push @validation_messages,
                        "data item '$tag' value must not have " .
                        'a top level container';
              }
          } elsif ( $type_container eq 'multiple' ) {
          # TODO: implement Multiple type check
          } elsif ( $type_container eq 'array' ) {
          # TODO: implement Array type check
          } elsif ( $type_container eq 'matrix') {
          # TODO: implement Matrix type check
          } elsif ( $type_container eq 'list' ) {
            if ( ref $value ne 'ARRAY' ) {
              push @validation_messages,
                   "data item '$tag' value must have a top level " .
                   'list container ([v1 v2 ...])';
            };
          } elsif ( lc $type_container eq lc 'table' ) {
            if ( ref $value ne 'HASH' ) {
               push @validation_messages,
                    "data item '$tag' value must have a top level " .
                    'table container ({k1:v1 k2:v2 ...})';
            };
          }
        }
      }
    }}}

    return \@validation_messages;
}

##
# Checks enumerator values against the DDLm dictionary file.
# @param $data
#       The data structure of the validated dictionary (as returned by the
#       'build_search_struct' data structure).
# @param $dict
#       The data structure of the validation dictionary (as returned by the
#       'build_search_struct' data structure).
# @return
#       Array reference to a list of validation messages.
##
sub validate_enumerators
{
    my ($data, $dict) = @_;

    my @validation_messages;

    for my $scope ( 'Dictionary', 'Category', 'Item' ) {
    for my $instance ( keys %{$data->{$scope}} ) {
    for my $tag ( @{$data->{$scope}{$instance}{'tags'}} ) {
      if ( exists $dict->{'Item'}{$tag} ) {
        my $validation_item = $dict->{'Item'}{$tag};
        if ( exists $validation_item->{'values'}{'_enumeration_set.state'} ) {
          my @enumeration_values = @{
                                $validation_item->{'values'}
                                {'_enumeration_set.state'} };
          my $type_container = lc $default_ddlm_values{'_type.container'};
          if ( exists $validation_item->{'values'}{'_type.container'}) {
            $type_container = lc $validation_item->{'values'}{'_type.container'}[0];
          }

          for my $value ( @{$data->{$scope}{$instance}{'values'}{$tag}} ) {
            if ( $type_container eq lc 'single' ) {
              # skip special CIF2 values
              if ( $value ne '?' && $value ne '.' ) {
                # FIXME: fc should probably be used instead of uc, but it is
                # not supported by older Perl versions
                if (! any { uc $value eq uc $_ } @enumeration_values ) {
                    warn "data item '$tag' value \"$value\" "
                    . 'must be one of the enumeration values '
                    . '[' . ( join ', ', @enumeration_values ) . ']' . "\n";
                }
              }
            # !!! Mainly targeted at '_type.contents'.
            # !!! Might be deprecated soon.
            } elsif ( $type_container eq 'multiple' ) {
              if (! any { uc $value  eq uc $_ } @enumeration_values ) {
            #     print "$instance: $tag: $value is not permitted\n";
            #  warn "data item '$tag' value \"$value\" "
            #     . 'must be one of the enumeration values '
            #     . '[' . ( join ', ', @enumeration_values ) . ']. '
            #     . 'This message might be a false positive since '
            #     . 'handling of enumeration values with the ' 
            #     . "'Multiple' type container is not yet implemented\n";
            }
            # TODO: consider all of these combinations?
            # even if they don't really occur?
            } elsif ( lc $type_container eq 'array' ) {

            } elsif ( lc $type_container eq 'matrix') {

            } elsif ( lc $type_container eq 'list' ) {

            } elsif ( lc $type_container eq 'table' ) {

            }
          }
        }
      }
    }}}

    return \@validation_messages;
}

sub validate_range
{
    my ($data, $dict) = @_;

    # TODO: maybe it should be a global variable?
    my $signed_float =
        '(?:[-+]?' .
        '(?:[0-9]+(?:\.[0-9]*)?|\.[0-9]+)' .
        '(?:[eE][-+]?[0-9]+)?)';

    my @validation_messages;

    for my $scope ( 'Dictionary', 'Category', 'Item' ) {
    for my $instance ( keys %{$data->{$scope}} ) {
    for my $tag ( @{$data->{$scope}{$instance}{'tags'}} ) {
      if ( exists $dict->{'Item'}{$tag} ) {
        my $validation_item = $dict->{'Item'}{$tag};
        if ( exists $validation_item->{'values'}{'_enumeration.range'} ) {
          for my $value ( @{$data->{$scope}{$instance}{'values'}{$tag}} ) {
            $validation_item->{'values'}{'_enumeration.range'}[0] =~
                /^($signed_float)?:($signed_float)?$/;
            my $min = $1;
            my $max = $2;
            my $old_value = $value;
            $value =~ s/\($signed_float\)$//;
            if ( !is_in_range_numeric( $value, {'min' => $min, 'max' => $max}) ) {
                push @validation_messages,
                    "data item '$tag' value '$old_value' should be in range " .
                     ( defined $min ? "[$min" : '(-inf' ) . ',' .
                     ( defined $max ? "$max]" : '+inf)' );
            }
          }
        }
      }
    }}}

    return \@validation_messages;
}


## TODO: the subroutine is copied from the cif_validate script
## NOTE: the subroutine has been renamed from check_against_range_numb to
# is_in_range_numeric
# Checks numeric value against an inclusive numeric range.
# @param $value
#       Value to be checked.
# @param $param
#       Parameter hash with the following keys:
#         {
#           'min' - => 0,
#                The minimum range value.
#           'max'   => 10,
#                The maximum range value.
#           'sigma  => 0.1
#               Standard deviation to be used when comparing numeric values
#               (3 sigma rule). If sigma is not provided, values are compared
#               disregarding the standard deviation.
#         }
# @return
#        0 if the value is out of the provided range or is not a number
#          at all;
#        1 if the value is in the provided range.
##
sub is_in_range_numeric
{
    my ( $value, $param ) = @_;

    my $min   = $param->{'min'};
    my $max   = $param->{'max'};
    my $sigma = $param->{'sigma'};

    if( ! looks_like_number($value) ) {
        return 0;
    }

    if( defined $sigma ) {
        $min = $min - 3 * $sigma if defined $min;
        $max = $max + 3 * $sigma if defined $max;
    };

    if(
        ( !defined $max || $value <= $max )
        &&
        ( !defined $min || $value >= $min )
    ) {
        return 1;
    }
    return 0;
}

##
# Checks scope restrictions for data items in a DDLm dictionary file.
# @param $data
#       The data structure of the validated dictionary (as returned by the
#       'build_search_struct' data structure).
# @param $dict
#       The data structure of the validation dictionary (as returned by the
#       'build_search_struct' data structure). Most likely this dictionary
#       will be the DDLm dictionary.
# @return
#       Array reference to a list of validation messages.
##
sub validate_scope_restrictions
{
    my ($data, $dict) = @_;

      my $valid_application = $dict->{'Datablock'}
                              {'values'}{'_dictionary_valid.application'};
      my $valid_attributes  = $dict->{'Datablock'}
                              {'values'}{'_dictionary_valid.attributes'};
      # The DDLm dictionary stores scope restriction data in the form:
      # [SCOPE RESTRICTION], i.e. [DICTIONARY MANDATORY]
      my %dict_restrictions;
      for (my $i = 0; $i < @{$valid_application}; $i++) {
          $dict_restrictions
            {$valid_application->[$i][0]}
            {$valid_application->[$i][1]} = $valid_attributes->[$i]
      };
      # expand valid attribute categories into individual data item names
      foreach my $scope (keys %dict_restrictions) {
        foreach my $option ( keys %{$dict_restrictions{$scope}} ) {
            $dict_restrictions{$scope}{$option} =
                expand_categories( $dict_restrictions{$scope}{$option}, $dict );
        }
      }

      my @validation_messages;
      for my $scope ( 'Dictionary', 'Category', 'Item' ) {
        for my $instance ( keys %{$data->{$scope}} ) {
          my %mandatory   = map { $_ => 0 } @{$dict_restrictions{$scope}{'Mandatory'}};
          my %recommended = map { $_ => 0 } @{$dict_restrictions{$scope}{'Recommended'}};
          my %prohibited  = map { $_ => 0 } @{$dict_restrictions{$scope}{'Prohibited'}};
          for my $tag ( @{$data->{$scope}{$instance}{'tags'}} ) {
              if ( exists $prohibited{$tag} ) {
                push @validation_messages,
                     "data item '$tag' is prohibited in the '$scope' scope of " .
                     "the $instance frame";
              }
              $mandatory{$tag}   = 1 if ( exists $mandatory{$tag} );
              $recommended{$tag} = 1 if ( exists $recommended{$tag} );
          }
          foreach my $tag (keys %mandatory) {
            if ( $mandatory{$tag} == 0 ) {
                push @validation_messages,
                    "data item '$tag' is mandatory in the '$scope' scope of " .
                    "the $instance frame"
            }
          }

          foreach my $tag (keys %recommended) {
            if ( $recommended{$tag} == 0 ) {
                # The _category_key.name and _category.key_id are recommended
                # for the CATEGORY scope, however, they make no sense if
                # the CATEGORY is unlooped
                # TODO: figure out what is the IUCr policy towards this
                if ( ( $tag eq '_category_key.name' || $tag eq '_category.key_id' ) &&
                      $scope eq 'Category' &&
                      ( !exists $data->{$scope}{$instance}{'values'}{'_definition.class'}[0] ||
                      lc $data->{$scope}{$instance}{'values'}{'_definition.class'}[0] ne 'loop' ) ) {
                    next;
                }

                push @validation_messages,
                    "data item '$tag' is recommended in the '$scope' scope of " .
                    "the $instance frame"
            }
          }
        }
      }

    return \@validation_messages;
}

sub get_data_names
{
    my ($datablock) = @_;

    my %data_names;

    for ( @{$datablock->{'tags'}} ) {
        $data_names{$_} = 1;
    };

    for my $saveblock ( @{$datablock->{'save_blocks'}} ) {
        for ( @{$saveblock->{'tags'}} ) {
            $data_names{$_} = 1;
        };
    };

    return \%data_names;
}

##
# Builds a data structure that is more convenient to traverse in regards to
# the Dictionary, Category and Item contexts classification.
# @param $data
#       CIF datablock as returned by the COD::CIF::Parser.
# @return $struct
#       Hash reference with the following keys:
#       $struct = {
#        'Dictionary' -- a hash of all data blocks that belong to the
#                        Dictionary scope.
#        'Category'   -- a hash of all save blocks that belong to the
#                        Category scope;
#        'Item'       -- a hash of all save blocks that belong to the
#                        Item scope;
#        'Datablock'  -- a reference to the input $data structure
#    };
##
sub build_search_struct
{
    my ($data) = @_;

    my %categories;
    my %items;
    my %tags;
    for my $saveblock ( @{$data->{'save_blocks'}} ) {
        my $values = $saveblock->{values};

        if ( exists $values->{'_definition.scope'} ) {
            if ( $values->{'_definition.scope'}[0] eq 'Dictionary' ) {
                next; #
            } elsif ( $values->{'_definition.scope'}[0] eq 'Category' ) {
                $categories{ $values->{'_definition.id'}[0] } = $saveblock;
                if (exists $values->{'_alias.definition_id'}) {
                    for ( @{$values->{'_alias.definition_id'}} ) {
                        $values->{'original_tags'}{lc $_} = $_;
                        $categories{ lc $_ } = $saveblock;
                    }
                }
            } elsif ( $values->{'_definition.scope'}[0] eq 'Item' ) {
                $items{ $values->{'_definition.id'}[0] } = $saveblock;
                if (exists $values->{'_alias.definition_id'}) {
                    for ( @{$values->{'_alias.definition_id'}} ) {
                        $values->{'original_tags'}{lc $_} = $_;
                        $items{ lc $_ } = $saveblock;
                    }
                }
            } else {
                # this error should be reported by the enumeration check
            }
        } else {
            # ITEM is currently stated as the default value
            $items{ $values->{'_definition.id'}[0] } = $saveblock;
            if (exists $values->{'_alias.definition_id'}) {
                for ( @{$values->{'_alias.definition_id'}} ) {
                    $values->{'original_tags'}{lc $_} = $_;
                    $items{ lc $_ } = $saveblock;
                }
            }
        }
        $tags{ $values->{'_definition.id'}[0] } = 1;
        if (exists $values->{'_alias.definition_id'}) {
            for ( @{$values->{'_alias.definition_id'}} ) {
                $tags{ lc $_ } = 1;
            }
        }
    };

    my $struct = {
        'Dictionary' => { $data->{'name'} => $data },
        'Category'   => \%categories,
        'Item'       => \%items,
        'Tags'       => \%tags,
        'Datablock'  => $data
    };

    return $struct;
}

#
# dictionary = {
#   'file_path'       => [ 'dir1', 'dir2', 'dir3' ]
#   'container_file' =>
#   'imported_files'  =>
#   'parser_options'  =>
# }
#
# TODO: consider a more conservative dictionary import system
#
sub get_imported_files
{
    my ($params) = @_;
    my $file_path = $params->{'file_path'};
    my $container_file = $params->{'container_file'};
    my %imported_files = %{$params->{'imported_files'}};
    my $parser_options = $params->{'parser_options'};

    for my $saveblock ( @{$container_file->{'save_blocks'}} ) {
      if ( exists $saveblock->{'values'}{'_import.get'} &&
           exists $saveblock->{'values'}{'_import.get'}[0] ) {
        foreach my $import ( @{$saveblock->{'values'}{'_import.get'}[0]} ) {
          my $filename = $import->{'file'};
          if ( !exists $imported_files{$filename} ) {
            foreach my $path ( @{$file_path} ) {
              # TODO: the path ends up with a double slash
              if ( -f "$path/$filename" ) {
                my ( $import_data, $err_count, $messages ) =
                  parse_cif( "$path/$filename", $parser_options );
                # TODO: check how the error messages interact with the
                # subroutine context
                process_parser_messages( $messages, $die_on_error_level );
                $imported_files{$filename} = $import_data->[0];
                my $single_import = get_imported_files( {
                    'file_path'      => $file_path,
                    'container_file' => $import_data->[0],
                    'imported_files' => \%imported_files,
                    'parser_options' => $parser_options
                } );
                %imported_files = %{$single_import};
                last;
              }
            }
          }
        }
      }
    }

    return \%imported_files;
}

# TODO: check for cyclic relationships
sub merge_imported_files
{
    my ($dict, $imported_files) = @_;

    for my $saveblock ( @{$dict->{'save_blocks'}} ) {
      if ( exists $saveblock->{'values'}{'_import.get'} &&
           exists $saveblock->{'values'}{'_import.get'}[0] ) {
        foreach my $import ( @{$saveblock->{'values'}{'_import.get'}[0]} ) {
          my $filename = $import->{'file'};
          if ( exists $imported_files->{$filename} ) {
            my $imported_file = $imported_files->{$filename};
            $imported_file = merge_imported_files($imported_file, $imported_files);
            my $target_saveblock = $import->{'save'};
            foreach my $imported_saveblock ( @{$imported_file->{'save_blocks'}} ) {
              # TODO: check for case-sensitivity
              if ( $imported_saveblock->{'name'} eq $target_saveblock ) {
                $saveblock = merge_save_blocks($saveblock, $imported_saveblock);
              }
            }
          }
        }
      }
    }

    return $dict;
}

# TODO: rewrite as non-destructive?
sub merge_save_blocks
{
    my ($main_save_block, $auxilary_save_block) = @_;

    foreach my $key ( keys %{$auxilary_save_block->{'types'}} ) {
        $main_save_block->{'types'}{$key} = $auxilary_save_block->{'types'}{$key};
    }

    foreach my $key ( keys %{$auxilary_save_block->{'values'}} ) {
        $main_save_block->{'values'}{$key} = $auxilary_save_block->{'values'}{$key};
    }

    foreach my $key ( keys %{$auxilary_save_block->{'inloop'}} ) {
        $main_save_block->{'inloop'}{$key} =
            $auxilary_save_block->{'inloop'}{$key} +
            scalar @{$main_save_block->{'loops'}};
    }

    push @{$main_save_block->{'loops'}}, @{$auxilary_save_block->{'loops'}};
    push @{$main_save_block->{'tags'}}, @{$auxilary_save_block->{'tags'}};

    return $main_save_block;
}

sub expand_categories
{
    my ($categories, $dict) = @_;

    my @expanded_categories;
    foreach my $category (@{$categories}) {
        if ( exists $dict->{'Item'}{$category} ) {
            push @expanded_categories, $category;
        } elsif ( exists $dict->{'Category'}{$category} ) {
            for my $id (keys %{$dict->{'Item'}}) {
                if ( exists $dict->{'Item'}{$id}{'values'}{'_name.category_id'} &&
                     lc $dict->{'Item'}{$id}{'values'}{'_name.category_id'}[0] eq lc $category ) {
                    push @expanded_categories, $id;
                }
            }
            for my $id (keys %{$dict->{'Category'}}) {
                if ( exists $dict->{'Category'}{$id}{'values'}{'_name.category_id'}[0] &&
                     lc $dict->{'Category'}{$id}{'values'}{'_name.category_id'}[0] eq lc $category ) {
                    push @expanded_categories, @{expand_categories([ $id ], $dict)};
                }
            }
        } else {
          #  print keys %{$dict->{'Item'}};
          #  print "$category\n";
            die 'No such data item or category was found in dictionary';
        }
    }

    return \@expanded_categories;
}
