#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#* Checks a pair of DDL1/DDLm dictionaries for compatibility breaking
#* differences. Discrepancies between corresponding enumeration sets,
#* default values, permitted ranges as well as data items unique to
#* one of the dictionaries are reported.
#*
#* USAGE:
#*    $0 --ddl1 cif_core_ddl1.dic --ddlm cif_core_ddlm.dic --options
#**

use strict;
use warnings;
binmode STDOUT, ':encoding(UTF-8)';
binmode STDERR, ':encoding(UTF-8)';

use File::Basename;

use COD::CIF::Parser qw( parse_cif );
use COD::CIF::DDL::DDLm qw( get_imported_files
                            merge_imported_files
                            get_definition_scope
                            get_data_name
                            get_data_alias );
use COD::CIF::DDL::Ranges qw( parse_range );
use COD::SOptions qw( getOptions get_value );
use COD::SUsage qw( usage options );
use COD::ErrorHandler qw( process_parser_messages
                          process_warnings );
use COD::ToolsVersion;

my $use_parser = 'c';

my $ddl1_file;
my $ddlm_file;
my $legacy_type = 'ddl1';

#* OPTIONS:
#*   -1, --ddl1
#*                     The name of the DDL1 conforming dictionary that should
#*                     be used in the comparison.
#*   -m, --ddlm
#*                     The name of the DDLm conforming dictionary that should
#*                     be used in the comparison.
#*
#*   --legacy-dic-type ddl1
#*                     The type of the dictionary that should treated as the
#*                     legacy one. Accepted values: 'ddl1' (default), 'ddlm'.
#*
#*   --help, --usage
#*                     Output a short usage message (this message) and exit.
#*   --version
#*                     Output version information and exit.
#**
@ARGV = getOptions(
    '-1,--ddl1'              => sub { $ddl1_file = get_value() },
    '-m,--ddlm'              => sub { $ddlm_file = get_value() },

    '--legacy-dic-type'      => sub { $legacy_type = get_value() },

    '--options'              => sub{ options; exit },
    '--help,--usage'         => sub{ usage; exit; },
    '--version'              => sub {
                                    print 'cod-tools version ',
                                    $COD::ToolsVersion::Version, "\n";
                                    exit
                                }
);

my $die_on_error_level = {
    'ERROR'   => 1,
    'WARNING' => 0,
    'NOTE'    => 0,
};

my $options = { 'parser' => $use_parser, 'no_print' => 1 };
my ( $ddl1_data, $ddlm_data, $err_count, $messages );
( $ddl1_data, $err_count, $messages ) = parse_cif( $ddl1_file, $options );
process_parser_messages( $messages, $die_on_error_level );
# TODO: the DDLm dictionary should import all of its dependencies.
( $ddlm_data, $err_count, $messages ) = parse_cif( $ddlm_file, $options );
process_parser_messages( $messages, $die_on_error_level );

# This logic is copied from the ddlm_validate script
$ddlm_data = $ddlm_data->[0];
my($filename, $dirs, $suffix) = fileparse($ddlm_file);
my $imported_data = get_imported_files(
    {
        'container_file' => $ddlm_data,
        # TODO: the path should also be constructed from the command line
        # arguments as well as a command line variable
        'file_path'      => [ './', $dirs ],
        'imported_files' => {},
        'parser_options' => $options
    }
);
$ddlm_data = merge_imported_files( $ddlm_data, $imported_data );

my ($ddl1_name, $ddlm_name);
($ddl1_name, undef, $suffix) = fileparse($ddl1_file);
$ddl1_name .= $suffix;
($ddlm_name, undef, $suffix) = fileparse($ddlm_file);
$ddlm_name .= $suffix;

my $ddl1_dic;
{
    local $SIG{__WARN__} = sub {
        process_warnings( {
            'message'  => @_,
            'program'  => $0,
            'filename' => $ddl1_file,
        }, $die_on_error_level )
    };
    $ddl1_dic = ddl1_to_generic_dic($ddl1_data);
    $ddl1_dic->{'signature'} = "'$ddl1_name' DDL1";
}

my $ddlm_dic;
{
    local $SIG{__WARN__} = sub {
        process_warnings( {
            'message'  => @_,
            'program'  => $0,
            'filename' => $ddlm_file,
        }, $die_on_error_level )
    };
    $ddlm_dic = ddlm_to_generic_dic($ddlm_data);
    $ddlm_dic->{'signature'} = "'$ddlm_name' DDLm";
}

my $notes;
if ( $legacy_type eq 'ddl1' ) {
    $notes = check_dic_compatability( $ddl1_dic, $ddlm_dic )
} else {
    $notes = check_dic_compatability( $ddlm_dic, $ddl1_dic )
};

for ( @{$notes} ) {
    print "$0:: ${_}.\n"
}

sub find_unique_values
{
    my ($array_1, $array_2, $case_sensitive) = @_;

    my %seen;
    foreach ( @{$array_1} ) {
        $seen{($case_sensitive ? $_ : lc $_ )} = $_;
    }
    delete @seen {($case_sensitive ? @{$array_2} : map {lc $_} @{$array_2} )};
    my @unique = values %seen;
    return \@unique;
}

sub ddl1_to_generic_dic
{
    my ($data) = @_;

    my @tags;
    my %enum_values;
    my %enum_defaults;
    my %enum_ranges;
    for my $datablock ( @{$data} ) {
        my $values = $datablock->{'values'};
        next if !exists $values->{'_type'};
        next if $values->{'_type'}[0] eq 'null';
        if ( !exists $values->{'_name'} ) {
            warn "the '$datablock->{'name'}' data block does not contain " .
                 'the \'_definition.id\' data item -- data block will be ' .
                 'ignored' . "\n";
            next;
        }

        for my $name ( map { lc } @{$values->{'_name'}} ) {
            # Data names
            push @tags, $name;
            # Enumeration values
            if ( exists $values->{'_enumeration'} ) {
                $enum_values{$name} = $values->{'_enumeration'};
            }
            # Enumeration defaults
            if ( $values->{'_enumeration_default'} ) {
                $enum_defaults{$name} = $values->{'_enumeration_default'}[0];
            }
            # Enumeration ranges
            if ( exists $values->{'_enumeration_range'} ) {
                $enum_ranges{$name} = $values->{'_enumeration_range'}[0];
            }
        }
    }

    return { 'data_names'    => \@tags,
             'enum_values'   => \%enum_values,
             'enum_defaults' => \%enum_defaults,
             'enum_ranges'   => \%enum_ranges, };
}

sub ddlm_to_generic_dic
{
    my ($data) = @_;

    my @ddlm_tags;
    my %enum_values;
    my %enum_defaults;
    my %enum_ranges;
    for my $save_block ( @{$data->{'save_blocks'}} ) {
        next if get_definition_scope( $save_block ) ne 'Item';
        my $data_name = get_data_name( $save_block );
        if ( !defined $data_name ) {
            warn "the '$save_block->{'name'}' save block does not contain " .
                 'the \'_definition.id\' data item -- save block will be ' .
                 'ignored' . "\n";
            next;
        }

        my @data_names = ( lc $data_name );
        push @data_names, map { lc } @{get_data_alias($save_block)};
        my $values = $save_block->{'values'};

        # Enumeration values
        if ( defined $values->{'_enumeration_set.state'} ) {
            foreach ( @data_names ) {
                $enum_values{$_} = $values->{'_enumeration_set.state'};
            }
        }
        # Enumeration defaults
        if ( defined $values->{'_enumeration.default'} ) {
            foreach ( @data_names ) {
                $enum_defaults{$_} = $values->{'_enumeration.default'}[0];
            }
        }
        # Enumeration defaults
        if ( defined $values->{'_enumeration.range'} ) {
            foreach ( @data_names ) {
                $enum_ranges{$_} = $values->{'_enumeration.range'}[0];
            }
        }

        # Data names
        push @ddlm_tags, @data_names;
    }

    return { 'data_names'    => \@ddlm_tags,
             'enum_values'   => \%enum_values,
             'enum_defaults' => \%enum_defaults,
             'enum_ranges'   => \%enum_ranges, };
}

sub check_dic_compatability
{
    my ( $old_dic, $new_dic ) = @_;

    my $signatures = {
        'old_dic_signature' => $old_dic->{'signature'},
        'new_dic_signature' => $new_dic->{'signature'},
    };

    my @compatability_notes;
    my %new_tags = map { $_ => 1 } @{$new_dic->{'data_names'}};
    for my $tag ( @{$old_dic->{'data_names'}} ) {
        if ( exists $new_tags{$tag} ) {
            push @compatability_notes,
                 @{ compare_enumeration_values(
                        $tag,
                        $old_dic->{'enum_values'},
                        $new_dic->{'enum_values'},
                        $signatures ) };
            push @compatability_notes,
                 @{ compare_enumeration_defaults(
                        $tag,
                        $old_dic->{'enum_defaults'},
                        $new_dic->{'enum_defaults'},
                        $signatures ) };
            push @compatability_notes,
                 @{ compare_enumeration_ranges(
                        $tag,
                        $old_dic->{'enum_ranges'},
                        $new_dic->{'enum_ranges'},
                        $signatures ) };
        } else {
            push @compatability_notes,
                 "WARNING, data name '$tag' is defined in the " .
                 $signatures->{'old_dic_signature'} .
                 ' dictionary, but seems to be missing in the ' .
                 $signatures->{'new_dic_signature'} . ' dictionary';
        }
    }

    return \@compatability_notes;
}

sub are_equivalent_limits
{
    my ($limit_1, $limit_2) = @_;

    my $sigma = 0.000001;

    if ( !defined $limit_1 && !defined $limit_2 ) {
        return 1;
    } elsif ( !defined $limit_1 || !defined $limit_2 ) {
        return 0;
    } elsif ( abs($limit_1 - $limit_2) > $sigma ) {
        return 0;
    }

    return 1;
}

sub compare_enumeration_values
{
    my ( $tag, $old_enum_values, $new_enum_values, $signatures ) = @_;

    my $new_dic_signature = $signatures->{'new_dic_signature'};
    my $old_dic_signature = $signatures->{'old_dic_signature'};

    return [] if !exists $old_enum_values->{$tag};

    my $unique_in_old = $old_enum_values->{$tag};
    if ( exists $new_enum_values->{$tag} ) {
        $unique_in_old = find_unique_values( $old_enum_values->{$tag},
                                             $new_enum_values->{$tag}, 0 );
    }

    my @messages;
    if ( @{$unique_in_old} ) {
        push @messages,
             'WARNING, enumeration values [' .
             ( join ',', map {"'$_'"} sort @{$unique_in_old} ) .
            "] of data item '$tag' are defined in " .
            "the $old_dic_signature dictionary, but not in " .
            "the $new_dic_signature dictionary";
    };

    return \@messages;
}

sub compare_enumeration_defaults
{
    my ( $tag, $old_enum_default, $new_enum_default, $signatures ) = @_;

    my $new_dic_signature = $signatures->{'new_dic_signature'};
    my $old_dic_signature = $signatures->{'old_dic_signature'};

    return [] if !exists $old_enum_default->{$tag};

    my @messages;
    if ( exists $new_enum_default->{$tag} ) {
        if ( $old_enum_default->{$tag} ne $new_enum_default->{$tag} ) {
            push @messages,
                 "WARNING, enumeration defaults of data item '$tag' differ in " .
                 "the $old_dic_signature and $new_dic_signature dictionaries " .
                 "('$old_enum_default->{$tag}' vs. '$new_enum_default->{$tag}')";
        }
    } else {
        push @messages,
             "WARNING, enumeration default '$old_enum_default->{$tag}' " .
             "is defined for data item '$tag' in the $old_dic_signature " .
             "dictionary, but not in the $new_dic_signature dictionary";
    }

    return \@messages;
}

sub compare_enumeration_ranges
{
    my ( $tag, $old_enum_range, $new_enum_range, $signatures ) = @_;

    my $new_dic_signature = $signatures->{'new_dic_signature'};
    my $old_dic_signature = $signatures->{'old_dic_signature'};

    return [] if !exists $old_enum_range->{$tag};

    my @messages;
    if ( exists $new_enum_range->{$tag} ) {
        my @old_range = @{parse_range($old_enum_range->{$tag})};
        my @new_range = @{parse_range($new_enum_range->{$tag})};
        if ( !are_equivalent_limits( $old_range[0], $new_range[0] ) ||
             !are_equivalent_limits( $old_range[1], $new_range[1] ) ) {
            push @messages,
                 "WARNING, enumeration range of data item '$tag' differ in " .
                 "the $old_dic_signature and $new_dic_signature dictionaries " .
                 "('$old_enum_range->{$tag}' vs. '$new_enum_range->{$tag}')";
        }
    } else {
        push @messages,
             "WARNING, enumeration range '$old_enum_range->{$tag}' " .
             "is defined for data item '$tag' in the $old_dic_signature " .
             "dictionary, but not in the $new_dic_signature dictionary";
    }

    return \@messages;
}
