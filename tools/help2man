#!/bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
# Generate man page for a script, marked up according to SOptions Perl
# module.
#**

use strict;
use warnings;
use File::Basename qw( basename );
use COD::SOptions qw( getOptions );
use COD::SUsage qw( usage options );

my $name;
my $bugs_url;
my $bugs_email;

my $format = 'man';

my $read_stdin = 0;

#* USAGE:
#*     $0 --options script script*
#*
#* OPTIONS:
#*     --man
#*          Generate a man page. Default option.
#*
#*     --wiki
#*          Generate a wiki page.
#*
#*     --mdwn, --markdown
#*          Generate output in Markdown format.
#*
#*     --name
#*          Name of the program.
#*
#*     --stdin, --read-stdin
#*          Read help file from STDIN.
#*
#*     --bugs-url
#*          Specify Web URL for bug reporting.
#*
#*     --bugs-email
#*          Specify e-mail address for bug reporting.
#*
#*     --help, --usage
#*          Print a short usage message (this message) and exit.
#**
@ARGV = getOptions(
    '--man'             => sub { $format = 'man' },
    '--wiki'            => sub { $format = 'wiki' },
    '--mdwn,--markdown' => sub { $format = 'markdown' },

    '--name' => \$name,
    '--stdin,--read-stdin' => sub { $read_stdin = 1 },

    '--bugs-url'   => \$bugs_url,
    '--bugs-email' => \$bugs_email,

    '--options'      => sub { options; exit },
    '--help,--usage' => sub { usage; exit }
);

@ARGV = ( '-' ) unless @ARGV;

for my $filename (@ARGV) {
    $name = basename( $filename ) unless defined $name;
    my( $help, $errors );
    if( $read_stdin ) {
        $help = join '', <>;
    } else {
        do {
            local *STDOUT;
            local *STDERR;
            local $0 = $name;
            open( STDOUT, '>', \$help );
            open( STDERR, '>', \$errors );
            usage( $filename );
        };
        die $errors if $errors;
    }

    my @help = split( /\n/, $help );

    my @head;
    my @usage;
    my @options;
    my @environment;

    my %flags = ( in_head => 1 );
    my $opt_indent;
    while( @help ) {
        $_ = shift @help;

        if(    /^\s*usage:\s*$/i ) {
            %flags = ( in_usage => 1 );
            next;
        }
        elsif( /^\s*options:\s*$/i ) {
            %flags = ( in_options => 1 );
            next;
        }
        elsif( /^\s*environment variables:\s*$/i ) {
            %flags = ( in_environment => 1 );
            next;
        }

        if(    exists $flags{in_head} ) {
            s/^\s+//;
            push( @head, $_ );
        }
        elsif( exists $flags{in_usage} ) {
            s/^\s+//;
            push( @usage, $_ );
        }
        elsif( exists $flags{in_options} ) {
            # Require all options to be prefixed by the same amount
            # of whitespace
            if( /^(\s*)\-\S/ ) {
                if( !defined $opt_indent ) {
                    $opt_indent = length( $1 );
                }
                if( length( $1 ) == $opt_indent && @options ) {
                    push @options, '';
                }
            }
            push( @options, $_ );
        }
        elsif( exists $flags{in_environment} ) {
            push( @environment, $_ );
        }
    }

    my $options_indent_length = get_min_indent_length(\@options);
    @options = map { $_ ne ''
                            ? substr( $_, $options_indent_length )
                            : '' } @options;
    my $environment_indent_length = get_min_indent_length(\@environment);
    @environment =
               map { $_ ne ''
                            ? substr( $_, $environment_indent_length )
                            : '' } @environment;

    my $options;
    my $environment;
    if( $format eq 'man' ) {
        @head    = map { escape_dashes_in_man_page_line($_) } @head;
        @usage   = map { escape_dashes_in_man_page_line($_) } @usage;
        @options = map { escape_dashes_in_man_page_line($_) } @options;
        $options = join "\n", @options;
        if (@environment) {
            @environment = map { escape_dashes_in_man_page_line($_) } @environment;
            $environment = join "\n", @environment;
        }
    } elsif( $format eq 'wiki' ) {
        $options = sprint_wiki_definition_list(\@options, '^-');
        $environment = sprint_wiki_definition_list(\@environment, '^[A-Z_]+$');
    } elsif( $format eq 'markdown' ) {
        $options = sprint_markdown_definition_list(\@options, '^-');
        $environment = sprint_markdown_definition_list(\@environment, '^[A-Z_]+$');
    } else {
        die "$0: unknown format: '$format'"
    }

    my $head    = join "\n", @head;
    my $usage   = join "\n\n", @usage;

    my $head_first_line;
    if( $head ) {
        $head_first_line = $head;
        $head_first_line =~ s/\n+/ /g;
        $head_first_line =~ s/^\s+//;
    } else {
        $head_first_line = 'to be described...';
    }

    $head    = 'to be described...' unless $head;
    $usage   = "$name [options] [input files]" unless $usage;

    if( $format eq 'man' ) {
        print <<"END";
.TH $name
.SH NAME
$name \\- $head_first_line
.SH SYNOPSIS
$usage
.SH DESCRIPTION
$head
END
        if (defined $options) {
            print '.SH OPTIONS' . "\n";
            print $options . "\n";
        }
        if (defined $environment) {
            print '.SH ENVIRONMENT VARIABLES' . "\n";
            print $environment . "\n";
        }
    } elsif( $format eq 'wiki' ) {
        $head =~ s/^\s*//;
        $head = lcfirst( $head );
        print <<"END";
'''$name''' &ndash; $head
== Synopsis ==
  $usage
END
        if (defined $options) {
            print '== Options ==' . "\n";
            print $options . "\n";
        }
        if (defined $environment) {
            print '== Environment variables ==' . "\n";
            print $environment . "\n";
        }
    } elsif( $format eq 'markdown' ) {
        $head =~ s/^\s*//;
        $head = lcfirst( $head );
        print <<"END";
**$name** &ndash; $head
# Synopsis
    $usage
END
        if (defined $options) {
            print '# Options' . "\n";
            print $options . "\n";
        }
        if (defined $environment) {
            print '# Environment variables' . "\n";
            print $environment . "\n";
        }
    } else {
        die "$0: unknown format: '$format'"
    }

    my @bugs_contacts;
    if( $format eq 'markdown' ) {
        push( @bugs_contacts, "Report **$name** bugs using Web: <$bugs_url>" )
            if defined $bugs_url;
        push( @bugs_contacts, "Report **$name** bugs using e-mail: <$bugs_email>" )
            if defined $bugs_email;
    } else {
        push( @bugs_contacts, "Report $name bugs using Web: $bugs_url" )
            if defined $bugs_url;
        push( @bugs_contacts, "Report $name bugs using e-mail: $bugs_email" )
            if defined $bugs_email;
    }

    if( @bugs_contacts > 0 ) {
        if( $format eq 'man' ) {
            print ".SH \"REPORTING BUGS\"\n" .
                  join( "\n.br\n",
                        map { escape_dashes_in_man_page_line($_) }
                            @bugs_contacts ) . "\n";
        } elsif( $format eq 'wiki' ) {
            print "== Reporting bugs ==\n" . join( "\n\n", @bugs_contacts ) . "\n";
        } elsif( $format eq 'markdown' ) {
            print "\n# Reporting bugs\n" . join( "\n\n", @bugs_contacts ) . "\n";
        } else {
            die "$0: unknown format: '$format'"
        }
    }
}

##
# Escapes all of the dash symbols ('-') symbols in a given text string
# according to the man page symbol escape rules.
#
# @param $line
#       Text string that should be processed.
# @return $line
#       Line with the escaped dash symbols.
##
sub escape_dashes_in_man_page_line
{
    my ($line) = @_;

    $line =~ s/[-]/\\-/g;

    return $line;
}

##
# Determines the length of the minimal prefix whitespace prefix
# that applies to all of the provided text strings.
#
# @param $lines
#       Reference to an array of text strings.
# @return
#       Length of the minimal whitespace prefix.
##
sub get_min_indent_length
{
    my ($lines) = @_;

    my $indent_length;
    for( @{$lines} ) {
        next if $_ eq '';
        next if !/^(\s*)/;
        if( !defined $indent_length ||
            $indent_length > length( $1 ) ) {
            $indent_length = length( $1 );
        }
    }

    $indent_length = 0 if !defined $indent_length;

    return $indent_length;
}

##
# Produces a multiline string that contains a Wiki definition list
# out of several text strings.
#
# @param $input_lines
#       Reference to an array of text strings.
# @param $term_line_regex
#       Regular expression string used to separate the definition
#       term lines (i.e. option names, environment variable names)
#       from the definition text lines.
# @return
#        Multiline string that contains a Wiki definition list or
#        undef if such value could not be produced.
##
sub sprint_wiki_definition_list
{
    my ($input_lines, $term_line_regex) = @_;

    return if !@{$input_lines};

    my @definition_list;
    push @definition_list, ';';
    my $last_line;
    for( grep { $_ ne '' } @{$input_lines} ) {
        if( !defined $last_line ) {
            $last_line = $_;
            next;
        }
        if( /$term_line_regex/ ) {
            if( $last_line =~ /$term_line_regex/ ) {
                push @definition_list, "$last_line ";
            } else {
                push @definition_list, "$last_line\n";
                push @definition_list, ';';
            }
        } else {
            s/^\s+//;
            if( $last_line =~ /$term_line_regex/ ) {
                push @definition_list, "$last_line\n";
                push @definition_list, ':';
            } else {
                push @definition_list, "$last_line ";
            }
        }
        $last_line = $_;
    }
    push @definition_list, $last_line;

    my $definition_list_string = join '', @definition_list;

    return $definition_list_string;
}

##
# Produces a multiline string that contains a Markdown definition list
# out of several text strings.
#
# @param $input_lines
#       Reference to an array of text strings.
# @param $term_line_regex
#       Regular expression string used to separate the definition
#       term lines (i.e. option names, environment variable names)
#       from the definition text lines.
# @return
#        Multiline string that contains a Markdown definition list or
#        undef if such value could not be produced.
##
sub sprint_markdown_definition_list
{
    my ($input_lines, $term_line_regex) = @_;

    return if !@{$input_lines};

    my @definition_list;
    push @definition_list, '* `';

    my $last_line;
    for( grep { $_ ne '' } @{$input_lines} ) {
        if( !defined $last_line ) {
            $last_line = $_;
            next;
        }
        if( /$term_line_regex/ ) {
            if( $last_line =~ /$term_line_regex/ ) {
                push @definition_list, "$last_line ";
            } else {
                push @definition_list, "$last_line\n";
                push @definition_list, "\n* `";
            }
        } else {
            s/^\s+//;
            if( $last_line =~ /$term_line_regex/ ) {
                push @definition_list, "$last_line`\n";
                push @definition_list, "\n  ";
            } else {
                push @definition_list, "$last_line ";
            }
        }
        $last_line = $_;
    }
    push @definition_list, $last_line;

    my $definition_list_string = join '', @definition_list;

    return $definition_list_string;
}
