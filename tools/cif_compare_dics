#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#* Checks a pair of DDL1/DDLm dictionaries for compatibility breaking
#* differences. Discrepancies between corresponding enumeration sets,
#* default values, permitted ranges as well as data items unique to
#* one of the dictionaries are reported.
#*
#* USAGE:
#*    $0 --ddl1 cif_core_ddl1.dic --ddlm cif_core_ddlm.dic --options
#**

use strict;
use warnings;
binmode STDOUT, ':encoding(UTF-8)';
binmode STDERR, ':encoding(UTF-8)';

use File::Basename;

use COD::CIF::Parser qw( parse_cif );
use COD::CIF::DDL::DDLm qw( get_imported_files
                            merge_imported_files
                            get_definition_scope
                            get_data_name
                            get_data_alias );
use COD::CIF::DDL::Ranges qw( parse_range );
use COD::SOptions qw( getOptions get_value );
use COD::SUsage qw( usage options );
use COD::ErrorHandler qw( process_warnings
                          process_parser_messages
                          report_message );
use COD::ToolsVersion;

my $use_parser = 'c';

my $die_on_errors   = 1;
my $die_on_warnings = 0;
my $die_on_notes    = 0;

my $ddl1_file;
my $ddlm_file;
my $legacy_type = 'ddl1';

#* OPTIONS:
#*   -1, --ddl1
#*                     The name of the DDL1 conforming dictionary that should
#*                     be used in the comparison.
#*   -m, --ddlm
#*                     The name of the DDLm conforming dictionary that should
#*                     be used in the comparison.
#*
#*   --legacy-dic-type ddl1
#*                     The type of the dictionary that should treated as the
#*                     legacy one. Accepted values: 'ddl1' (default), 'ddlm'.
#*
#*   --continue-on-errors
#*                     Do not terminate script if errors are raised (default).
#*   --die-on-errors
#*                     Terminate script immediately if errors are raised.
#*   --continue-on-warnings
#*                     Do not terminate script if warnings are raised (default).
#*   --die-on-warnings
#*                     Terminate script immediately if warnings are raised.
#*   --continue-on-notes
#*                     Do not terminate script if notes are raised (default).
#*   --die-on-notes
#*                     Terminate script immediately if notes are raised.
#*
#*   --help, --usage
#*                     Output a short usage message (this message) and exit.
#*   --version
#*                     Output version information and exit.
#**
@ARGV = getOptions(
    '-1,--ddl1'              => sub { $ddl1_file = get_value() },
    '-m,--ddlm'              => sub { $ddlm_file = get_value() },

    '--legacy-dic-type'      => sub { $legacy_type = get_value() },

    '--continue-on-errors'   => sub { $die_on_errors = 0 },
    '--die-on-errors'        => sub { $die_on_errors = 1 },

    '--continue-on-warnings' => sub { $die_on_warnings = 0 },
    '--die-on-warnings'      => sub { $die_on_warnings = 1 },

    '--continue-on-notes'    => sub { $die_on_notes = 0 },
    '--die-on-notes'         => sub { $die_on_notes = 1 },

    '--options'              => sub{ options; exit },
    '--help,--usage'         => sub{ usage; exit; },
    '--version'              => sub {
                                    print 'cod-tools version ',
                                    $COD::ToolsVersion::Version, "\n";
                                    exit
                                }
);

my $die_on_error_level = {
    'ERROR'   => $die_on_errors,
    'WARNING' => $die_on_warnings,
    'NOTE'    => $die_on_notes
};

my $options = { 'parser' => $use_parser, 'no_print' => 1 };
my ( $ddl1_data, $ddlm_data, $err_count, $messages );
( $ddl1_data, $err_count, $messages ) = parse_cif( $ddl1_file, $options );
process_parser_messages( $messages, $die_on_error_level );
# TODO: the DDLm dictionary should import all of its dependencies.
( $ddlm_data, $err_count, $messages ) = parse_cif( $ddlm_file, $options );
process_parser_messages( $messages, $die_on_error_level );

# This logic is copied from the ddlm_validate script
$ddlm_data = $ddlm_data->[0];
my($filename, $dirs, $suffix) = fileparse($ddlm_file);
my $imported_data = get_imported_files(
    {
        'container_file' => $ddlm_data,
        # TODO: the path should also be constructed from the command line
        # arguments as well as a command line variable
        'file_path'      => [ './', $dirs ],
        'imported_files' => {},
        'parser_options' => $options
    }
);
$ddlm_data = merge_imported_files( $ddlm_data, $imported_data );

my ($ddl1_name, $ddlm_name);
($ddl1_name, undef, $suffix) = fileparse($ddl1_file);
$ddl1_name .= $suffix;
($ddlm_name, undef, $suffix) = fileparse($ddlm_file);
$ddlm_name .= $suffix;

my $ddl1_dic = ddl1_to_generic_dic($ddl1_data);
$ddl1_dic->{'signature'} = "'$ddl1_name' DDL1";
my $ddlm_dic = ddlm_to_generic_dic($ddlm_data);
$ddlm_dic->{'signature'} = "'$ddl1_name' DDLm";

my $notes;
if ( $legacy_type eq 'ddl1' ) {
    $notes = check_dic_compatability( $ddl1_dic, $ddlm_dic )
} else {
    $notes = check_dic_compatability( $ddlm_dic, $ddl1_dic )
};

for ( @{$notes} ) {
    print "$0:: ${_}.\n"
}

sub find_unique_values
{
    my ($array_1, $array_2, $case_sensitive) = @_;

    my %seen;
    foreach ( @{$array_1} ) {
        $seen{($case_sensitive ? $_ : lc $_ )} = $_;
    }
    delete @seen {($case_sensitive ? @{$array_2} : map {lc $_} @{$array_2} )};
    my @unique = values %seen;
    return \@unique;
}

sub ddl1_to_generic_dic
{
    my ($data) = @_;

    my @ddl1_tags;
    my %ddl1_enum_values;
    my %ddl1_enum_defaults;
    my %ddl1_enum_ranges;
    for my $datablock ( @{$data} ) {
        my $values = $datablock->{'values'};

        for my $name ( map { lc } @{$values->{'_name'}} ) {
            # Data names
            if ( exists $values->{'_type'} &&
                 $values->{'_type'}[0] ne 'null' ) {
                push @ddl1_tags, $name;
            }
            # Enumeration values
            if ( exists $values->{'_enumeration'} ) {
                $ddl1_enum_values{$name} = $values->{'_enumeration'};
            }
            # Enumeration defaults
            if ( $values->{'_enumeration_default'} ) {
                $ddl1_enum_defaults{$name} =
                            $values->{'_enumeration_default'}[0];
            }
            # Enumeration ranges
            if ( exists $values->{'_enumeration_range'} ) {
                $ddl1_enum_ranges{$name} =
                            $values->{'_enumeration_range'}[0];
            }
        }
    }

    return { 'data_names'    => \@ddl1_tags,
             'enum_values'   => \%ddl1_enum_values,
             'enum_defaults' => \%ddl1_enum_defaults,
             'enum_ranges'   => \%ddl1_enum_ranges, };
}

sub ddlm_to_generic_dic
{
    my ($data) = @_;

    my @ddlm_tags;
    my %ddlm_enum_values;
    my %ddlm_enum_defaults;
    my %ddlm_enum_ranges;
    for my $save_block ( @{$data->{'save_blocks'}} ) {
        next if get_definition_scope( $save_block ) ne 'Item';
        my $data_name = get_data_name( $save_block );
        next if !defined $data_name;

        my @data_names = ( lc $data_name );
        push @data_names, map { lc } @{get_data_alias($save_block)};
        my $values = $save_block->{'values'};

        # Enumeration values
        if ( defined $values->{'_enumeration_set.state'} ) {
            foreach ( @data_names ) {
                $ddlm_enum_values{$_} = $values->{'_enumeration_set.state'};
            }
        }

        # Enumeration defaults
        if ( defined $values->{'_enumeration.default'} ) {
            foreach ( @data_names ) {
                $ddlm_enum_defaults{$_} = $values->{'_enumeration.default'}[0];
            }
        }

        # Enumeration defaults
        if ( defined $values->{'_enumeration.range'} ) {
            foreach ( @data_names ) {
                $ddlm_enum_ranges{$_} = $values->{'_enumeration.range'}[0];
            }
        }

        # Data names
        push @ddlm_tags, @data_names;
    }

    return { 'data_names'    => \@ddlm_tags,
             'enum_values'   => \%ddlm_enum_values,
             'enum_defaults' => \%ddlm_enum_defaults,
             'enum_ranges'   => \%ddlm_enum_ranges, };
}

sub check_dic_compatability
{
    my ( $old_dic, $new_dic ) = @_;

    my $signatures = {
        'old_dic_signature' => $old_dic->{'signature'},
        'new_dic_signature' => $new_dic->{'signature'},
    };

    my @compatability_notes;
    my %new_tags = map { lc $_ => 1 } @{$new_dic->{'data_names'}};
    for my $tag ( @{$old_dic->{'data_names'}} ) {
        if ( exists $new_tags{lc $tag} ) {
            push @compatability_notes,
                 @{ compare_enumeration_values(
                        $tag,
                        $old_dic->{'enum_values'},
                        $new_dic->{'enum_values'},
                        $signatures ) };
            push @compatability_notes,
                 @{ compare_enumeration_defaults(
                        $tag,
                        $old_dic->{'enum_defaults'},
                        $new_dic->{'enum_defaults'},
                        $signatures ) };
            push @compatability_notes,
                 @{ compare_enumeration_ranges(
                        $tag,
                        $old_dic->{'enum_ranges'},
                        $ddlm_dic->{'enum_ranges'},
                        $signatures ) };
        } else {
            push @compatability_notes,
                 "WARNING, data name '$tag' is defined in the " .
                 $signatures->{'old_dic_signature'} .
                 ' dictionary, but seems to be missing in the ' .
                 $signatures->{'new_dic_signature'} . ' dictionary';
        }
    }

    return \@compatability_notes;
}

sub are_limits_equal
{
    my ($limit_1, $limit_2) = @_;

    my $sigma = 0.000001;

    if ( !defined $limit_1 && !defined $limit_2 ) {
        return 1;
    } elsif ( !defined $limit_1 || !defined $limit_2 ) {
        return 0;
    } elsif ( abs($limit_1 - $limit_2) > $sigma ) {
        return 0;
    }

    return 1;
}

sub compare_enumeration_values
{
    my ( $tag, $old_enum_values, $new_enum_values, $signatures ) = @_;

    my $new_dic_signature = $signatures->{'new_dic_signature'};
    my $old_dic_signature = $signatures->{'old_dic_signature'};

    return [] if !exists $old_enum_values->{$tag};

    my $unique_in_old = $old_enum_values->{$tag};
    if ( exists $old_enum_values->{$tag} ) {
        $unique_in_old = find_unique_values( $old_enum_values->{$tag},
                                             $new_enum_values->{$tag}, 0 );
    }

    my @messages;
    if ( @{$unique_in_old} ) {
        push @messages,
             'WARNING, enumeration values [' .
             ( join ',', map {"'$_'"} sort @{$unique_in_old} ) .
            "] of data item '$tag' are defined in " .
            "the $old_dic_signature dictionary, but not in " .
            "the $new_dic_signature dictionary";
    };

    return \@messages;
}

sub compare_enumeration_defaults
{
    my ( $tag, $old_enum_default, $new_enum_default, $signatures ) = @_;

    my $new_dic_signature = $signatures->{'new_dic_signature'};
    my $old_dic_signature = $signatures->{'old_dic_signature'};

    return [] if !exists $old_enum_default->{$tag};

    my @messages;
    if ( exists $new_enum_default->{$tag} ) {
        if ( $old_enum_default->{$tag} ne $new_enum_default->{$tag} ) {
            push @messages,
                 "WARNING, enumeration defaults of data item '$tag' differ in " .
                 "the $old_dic_signature and $new_dic_signature dictionaries " .
                 "('$old_enum_default->{$tag}' vs. '$new_enum_default->{$tag}')";
        }
    } else {
        push @messages,
             "WARNING, enumeration default '$old_enum_default->{$tag}' " .
             "is defined for data item '$tag' in the $old_dic_signature " .
             "dictionary, but not in the $new_dic_signature dictionary";
    }

    return \@messages;
}

sub compare_enumeration_ranges
{
    my ( $tag, $old_enum_range, $new_enum_range, $signatures ) = @_;

    my $new_dic_signature = $signatures->{'new_dic_signature'};
    my $old_dic_signature = $signatures->{'old_dic_signature'};

    return [] if !exists $old_enum_range->{$tag};

    my @messages;
    if ( exists $new_enum_range->{$tag} ) {
        my @old_range = @{parse_range($old_enum_range->{$tag})};
        my @new_range = @{parse_range($new_enum_range->{$tag})};
        if ( !are_limits_equal( $old_range[0], $new_range[0] ) ||
             !are_limits_equal( $old_range[1], $new_range[1] ) ) {
            push @messages,
                 "WARNING, enumeration range of data item '$tag' differ in " .
                 "the $old_dic_signature and $new_dic_signature dictionaries " .
                 "('$old_enum_range->{$tag}' vs. '$new_enum_range->{$tag}')";
        }
    } else {
        push @messages,
             "WARNING, enumeration range '$old_enum_range->{$tag}' " .
             "is defined for data item '$tag' in the $old_dic_signature " .
             "dictionary, but not in the $new_dic_signature dictionary";
    }

    return \@messages;
}
