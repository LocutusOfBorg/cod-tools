#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#* Compare dictionaries written in DDL1 and DDLm to each other and output
#* warning messages about mismatching data.
#*
#* USAGE:
#*    $0 --ddl1 cif_core_ddl1.dic --ddlm cif_core_ddlm.dic --options
#**

use strict;
use warnings;
binmode STDOUT, ':encoding(UTF-8)';
binmode STDERR, ':encoding(UTF-8)';

use File::Basename;

use COD::CIF::Parser qw( parse_cif );
use COD::CIF::DDL::DDLm qw( get_imported_files
                            merge_imported_files
                            merge_save_blocks );
use COD::SOptions qw( getOptions get_value );
use COD::SUsage qw( usage options );
use COD::ErrorHandler qw( process_warnings
                          process_parser_messages
                          report_message );
use COD::ToolsVersion;

my $use_parser = 'c';

my $die_on_errors   = 1;
my $die_on_warnings = 0;
my $die_on_notes    = 0;

my $ddl1_file;
my $ddlm_file;

#* OPTIONS:
#*   -1, --ddl1
#*                     The name of the DDL1 conforming dictionary that should
#                      be used in the comparison.
#*   -m, --ddlm
#*                     The name of the DDLm conforming dictionary that should
#                      be used in the comparison.
#*   --continue-on-errors
#*                     Do not terminate script if errors are raised (default).
#*   --die-on-errors
#*                     Terminate script immediately if errors are raised.
#*   --continue-on-warnings
#*                     Do not terminate script if warnings are raised (default).
#*   --die-on-warnings
#*                     Terminate script immediately if warnings are raised.
#*   --continue-on-notes
#*                     Do not terminate script if notes are raised (default).
#*   --die-on-notes
#*                     Terminate script immediately if notes are raised.
#*
#*   --help, --usage
#*                     Output a short usage message (this message) and exit.
#*   --version
#*                     Output version information and exit.
#**
@ARGV = getOptions(
    '-1,--ddl1'    => sub { $ddl1_file = get_value() },
    '-m,--ddlm'    => sub { $ddlm_file = get_value() },

    '--continue-on-errors'          => sub { $die_on_errors = 0 },
    '--die-on-errors'               => sub { $die_on_errors = 1 },

    '--continue-on-warnings' => sub { $die_on_warnings = 0 },
    '--die-on-warnings'      => sub { $die_on_warnings = 1 },

    '--continue-on-notes'    => sub { $die_on_notes = 0 },
    '--die-on-notes'         => sub { $die_on_notes = 1 },

    '--options'         => sub{ options; exit },
    '--help,--usage'    => sub{ usage; exit; },
    '--version'      => sub { print 'cod-tools version ',
                                 $COD::ToolsVersion::Version, "\n";
                                 exit }
);

my $die_on_error_level = {
    ERROR   => $die_on_errors,
    WARNING => $die_on_warnings,
    NOTE    => $die_on_notes
};

my $options = { 'parser' => $use_parser, 'no_print' => 1 };
my ( $ddl1_data, $ddlm_data, $err_count, $messages );
( $ddl1_data, $err_count, $messages ) = parse_cif( $ddl1_file, $options );
process_parser_messages( $messages, $die_on_error_level );
# TODO: the DDLm dictionary should import all of its dependencies.
( $ddlm_data, $err_count, $messages ) = parse_cif( $ddlm_file, $options );
process_parser_messages( $messages, $die_on_error_level );

# This logic is copied form the ddlm_validate script
$ddlm_data = $ddlm_data->[0];
my($filename, $dirs, $suffix) = fileparse($ddlm_file);
my $imported_data = get_imported_files(
    {
        'container_file' => $ddlm_data,
        # TODO: the path should also be constructed from the command line
        # arguments as well as a command line variable
        'file_path'      => [ './', $dirs ],
        'imported_files' => {},
        'parser_options' => $options
    }
);
$ddlm_data = merge_imported_files( $ddlm_data, $imported_data );

my ($ddl1_name, $ddlm_name);
($ddl1_name, undef, $suffix) = fileparse($ddl1_file);
$ddl1_name .= $suffix;
($ddlm_name, undef, $suffix) = fileparse($ddlm_file);
$ddlm_name .= $suffix;

# Print out data names that are present in the DDL1 version of the dictionary,
# but are missing in the 
my @ddl1_tags;
my %ddl1_enumerators;
my %ddl1_enumeration_defaults;
my %ddl1_enumeration_ranges;
for my $datablock ( @{$ddl1_data} ) {

    foreach my $name ( @{$datablock->{'values'}{'_name'}} ) {
        # Data names
        if ( exists $datablock->{'values'}{'_type'} &&
         $datablock->{'values'}{'_type'}[0] ne 'null' ) {
        push @ddl1_tags, $name;
        }
        # Enumerators
        if ( exists $datablock->{'values'}{'_enumeration'} ) {
            $ddl1_enumerators{$name} =
                $datablock->{'values'}{'_enumeration'};
        }
        # Enumeration defaults
        if ( exists $datablock->{'values'}{'_enumeration_default'} ) {
            $ddl1_enumeration_defaults{$name} =
                $datablock->{'values'}{'_enumeration_default'}[0];
        }
        # Enumeration ranges
        if ( exists $datablock->{'values'}{'_enumeration_range'} ) {
            $ddl1_enumeration_ranges{$name} =
                $datablock->{'values'}{'_enumeration_range'}[0];
        }
    }
}

my @ddlm_tags;
my %ddlm_enumerators;
my %ddlm_enumeration_defaults;
my %ddlm_enumeration_ranges;
for my $saveblock ( @{$ddlm_data->{'save_blocks'}} ) {
    if ( !exists $saveblock->{'values'}{'_definition.scope'} ||
         lc $saveblock->{'values'}{'_definition.scope'}[0] eq 'item' ) {
        # Data names
        if ( defined $saveblock->{'values'}{'_definition.id'} ) {
            push @ddlm_tags, @{$saveblock->{'values'}{'_definition.id'}};
        }
        if ( defined $saveblock->{'values'}{'_alias.definition_id'} ) {
            push @ddlm_tags, @{$saveblock->{'values'}{'_alias.definition_id'}};
        }

        # Enumerators
        if ( defined $saveblock->{'values'}{'_enumeration_set.state'} ) {
            $ddlm_enumerators{$saveblock->{'values'}{'_definition.id'}[0]} =
                $saveblock->{'values'}{'_enumeration_set.state'};

            if ( defined $saveblock->{'values'}{'_alias.definition_id'} ) {
                foreach ( @{$saveblock->{'values'}{'_alias.definition_id'}} ) {
                    $ddlm_enumerators{$_} =
                        $saveblock->{'values'}{'_enumeration_set.state'};
                }
            }
        }

        # Enumeration defaults
        if ( defined $saveblock->{'values'}{'_enumeration.default'} ) {
            $ddlm_enumeration_defaults{$saveblock->{'values'}{'_definition.id'}[0]} =
                $saveblock->{'values'}{'_enumeration.default'}[0];

            if ( defined $saveblock->{'values'}{'_alias.definition_id'} ) {
                foreach ( @{$saveblock->{'values'}{'_alias.definition_id'}} ) {
                    $ddlm_enumeration_defaults{$_} =
                        $saveblock->{'values'}{'_enumeration.default'}[0];
                }
            }
        }

        # Enumeration defaults
        if ( defined $saveblock->{'values'}{'_enumeration.range'} ) {
            $ddlm_enumeration_ranges{$saveblock->{'values'}{'_definition.id'}[0]} =
                $saveblock->{'values'}{'_enumeration.range'}[0];

            if ( defined $saveblock->{'values'}{'_alias.definition_id'} ) {
                foreach ( @{$saveblock->{'values'}{'_alias.definition_id'}} ) {
                    $ddlm_enumeration_ranges{$_} =
                        $saveblock->{'values'}{'_enumeration.range'}[0];
                }
            }
        }
    }
}

my %ddlm_tags = map { lc $_ => 1 } @ddlm_tags;

foreach ( @ddl1_tags ) {
    if ( !exists $ddlm_tags{lc $_} ) {
        warn "$0:: WARNING, data name '$_' is defined in the '$ddl1_name' DDL1 " .
             "dictionary, but seems to be missing in the '$ddlm_name' DDLm " .
             "dictionary.\n";
    }
}

# Checking enumerators
foreach ( keys %ddl1_enumerators ) {
    if ( exists $ddlm_enumerators{$_} ) {

        my $ddl1_only = find_unique_values( $ddl1_enumerators{$_},
                                            $ddlm_enumerators{$_}, 0 );

        my $ddlm_only = find_unique_values( $ddlm_enumerators{$_},
                                            $ddl1_enumerators{$_}, 0 );

        if ( @{$ddl1_only} ) {
            warn "$0:: WARNING, enumerator values [" .
            ( join ",", map {"'$_'"} @{$ddl1_only} ) . "] of data item '$_' " .
            "are defined in the '$ddl1_name' DDL1 dictionary, but not in the " .
            "'$ddlm_name' DDLm dictionary\n";
        };

        if ( @{$ddlm_only} ) {
            warn "$0:: WARNING, enumerator values [" .
            ( join ",", map {"'$_'"} @{$ddlm_only} ) . "] of data item '$_' " .
            "are defined in the '$ddlm_name' DDLm dictionary, but not in the " .
            "'$ddl1_name' DDLm dictionary\n";
        }
    } else {
        warn "$0:: WARNING, enumerator values [" .
             ( join ",", map {"'$_'"} @{$ddl1_enumerators{$_}} ) . '] ' .
             "of data item '$_' are defined in the '$ddl1_name' DDL1 dictionary," .
             "but not in the '$ddl1_name' DDLm dictionary\n";
    }
}

foreach ( keys %ddlm_enumerators ) {
    next if ( /[.]/ );
    if ( !exists $ddl1_enumerators{$_} ) {
        warn "$0:: WARNING, enumerator values [" .
             ( join ",", map {"'$_'"} @{$ddlm_enumerators{$_}} ) . '] ' .
             "of data item '$_' are defined in the '$ddlm_name' DDLm " .
             "dictionary, but not in the '$ddlm_name' DDLm dictionary\n";
    }
}

# Checking default enumeration values
foreach ( sort keys %ddl1_enumeration_defaults ) {
    if ( exists $ddlm_enumeration_defaults{$_} ) {
        if ( $ddl1_enumeration_defaults{$_} ne $ddlm_enumeration_defaults{$_} ) {
            warn "$0:: WARNING, enumeration defaults of data item '$_' " .
                 "differ in '$ddl1_name' DDL1 and '$ddlm_name' DDLm dictionaries " .
                 "($ddl1_enumeration_defaults{$_} vs. $ddlm_enumeration_defaults{$_})\n";
        }
    } else {
        warn "$0:: WARNING, enumeration default '$ddl1_enumeration_defaults{$_}' " .
             "is defined for data item '$_' in the '$ddl1_name' DDL1 " .
             "dictionary, but not in the '$ddlm_name' DDLm dictionary.\n";
    }
}

foreach ( sort keys %ddlm_enumeration_defaults ) {
    next if ( /[.]/ );
    if ( !exists $ddl1_enumeration_defaults{$_} ) {
        warn "$0:: WARNING, enumeration default '$ddlm_enumeration_defaults{$_}' " .
             "is defined for data item '$_' in the '$ddlm_name' DDLm " .
             "dictionary, but not in the '$ddl1_name' DDL1 dictionary.\n";
    }
}

# Checking enumeration ranges values
foreach ( sort keys %ddl1_enumeration_ranges ) {
    if ( exists $ddlm_enumeration_ranges{$_} ) {
        $ddl1_enumeration_ranges{$_} =~ /^([^:]*)?:([^:]*)?$/;
        my @ddl1_range = ($1, $2);
        $ddlm_enumeration_ranges{$_} =~ /^([^:]*)?:([^:]*)?$/;
        my @ddlm_range = ($1, $2);

        if ( !are_limits_equal( $ddl1_range[0], $ddlm_range[0] ) ||
             !are_limits_equal( $ddl1_range[1], $ddlm_range[1] ) ) {
            warn "$0:: WARNING, enumeration range of data item '$_' " .
                 "differ in '$ddl1_name' DDL1 and '$ddlm_name' DDLm dictionaries " .
                 "($ddl1_enumeration_ranges{$_} vs. $ddlm_enumeration_ranges{$_})\n";
        }
    } else {
        warn "$0:: WARNING, enumeration range '$ddl1_enumeration_ranges{$_}' " .
             "is defined for data item '$_' in the '$ddl1_name' DDL1 " .
             "dictionary, but not in the '$ddlm_name' DDLm dictionary.\n";
    }
}

foreach my $name ( sort keys %ddlm_enumeration_ranges ) {
    next if $name =~ ( /[.]/ );
    if ( !exists $ddl1_enumeration_ranges{$name} &&
         grep { $name eq $_ } @ddl1_tags ) {
        warn "$0:: WARNING, enumeration range '$ddlm_enumeration_ranges{$name}' " .
             "is defined for data item '$name' in the '$ddlm_name' DDLm " .
             "dictionary, but not in the '$ddl1_name' DDL1 dictionary.\n";
    }
}

sub find_unique_values
{
    my ($array_1, $array_2, $case_sensitive) = @_;

    my %seen;
    foreach ( @{$array_1} ) {
        $seen{($case_sensitive ? $_ : lc $_ )} = $_;
    }
    delete @seen {($case_sensitive ? @{$array_2} : map {lc $_} @{$array_2} )};
    my @unique = values %seen;
    return \@unique;
}

sub are_limits_equal
{
    my ($limit_1, $limit_2) = @_;

    my $sigma = 0.000001;

    if ( $limit_1 eq '' && $limit_2 eq '' ) {
        return 1;
    } elsif ( $limit_1 eq '' || $limit_2 eq '' ) {
        return 0;
    } elsif ( abs($limit_1 - $limit_2) > $sigma ) {
        return 0;
    }
    
    return 1;
}
