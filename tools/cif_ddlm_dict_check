#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#* Check DDLm dictionaries against a set of best practice rules.
#*
#* USAGE:
#*    $0 --options cif_core.dic
#**

use strict;
use warnings;
binmode STDOUT, ':encoding(UTF-8)';
binmode STDERR, ':encoding(UTF-8)';

use File::Basename;

use COD::CIF::Parser qw( parse_cif );
use COD::CIF::DDL::DDLm qw( build_search_struct
                            get_imported_files
                            merge_imported_files
                            get_type_contents
                            get_type_purpose
                            get_definition_class );
use COD::CIF::DDL::Ranges qw( parse_range
                              range_to_string
                              is_in_range );
use COD::SOptions qw( getOptions get_value );
use COD::SUsage qw( usage options );
use COD::ErrorHandler qw( process_warnings
                          process_parser_messages
                          report_message );
use COD::ToolsVersion;

my $use_parser = 'c';
my $report_redundant_range_limits = 0;

my $die_on_errors   = 1;
my $die_on_warnings = 0;
my $die_on_notes    = 0;

#* OPTIONS:
#*
#*   --report-redundant-range-limits
#*                     Report explicit range limits that match implicit
#*                     range limits imposed by the content type.
#*   --no-report-redundant-range-limits
#*                     Do not report explicit range limits that match implicit
#*                     range limits imposed by the content type (default).
#*   --continue-on-errors
#*                     Do not terminate script if errors are raised (default).
#*   --die-on-errors
#*                     Terminate script immediately if errors are raised.
#*   --continue-on-warnings
#*                     Do not terminate script if warnings are raised (default).
#*   --die-on-warnings
#*                     Terminate script immediately if warnings are raised.
#*   --continue-on-notes
#*                     Do not terminate script if notes are raised (default).
#*   --die-on-notes
#*                     Terminate script immediately if notes are raised.
#*
#*   --help, --usage
#*                     Output a short usage message (this message) and exit.
#*   --version
#*                     Output version information and exit.
#**
@ARGV = getOptions(
    '--report-redundant-range-limits'    =>
            sub { $report_redundant_range_limits = 1 },
    '--no-report-redundant-range-limits' =>
            sub { $report_redundant_range_limits = 0 },

    '--continue-on-errors'          => sub { $die_on_errors = 0 },
    '--die-on-errors'               => sub { $die_on_errors = 1 },

    '--continue-on-warnings' => sub { $die_on_warnings = 0 },
    '--die-on-warnings'      => sub { $die_on_warnings = 1 },

    '--continue-on-notes'    => sub { $die_on_notes = 0 },
    '--die-on-notes'         => sub { $die_on_notes = 1 },

    '--options'         => sub{ options; exit },
    '--help,--usage'    => sub{ usage; exit },
    '--version'      => sub { print 'cod-tools version ',
                                 $COD::ToolsVersion::Version, "\n";
                                 exit }
);

my $die_on_error_level = {
    ERROR   => $die_on_errors,
    WARNING => $die_on_warnings,
    NOTE    => $die_on_notes
};

for my $filename ( @ARGV ) {
    my $options = { 'parser' => $use_parser, 'no_print' => 1 };
    my ( $data, $err_count, $messages ) = parse_cif( $filename, $options );
    process_parser_messages( $messages, $die_on_error_level );

    $data = $data->[0];
    my($filename, $dirs, $suffix) = fileparse($filename);
    my $imported_data = get_imported_files(
    {
        'container_file' => $data,
        # TODO: the path should also be constructed from the command line
        # arguments as well as a command line variable
        'file_path'      => [ './', $dirs ],
        'imported_files' => {},
        'parser_options' => $options
    }
    );
    $data = merge_imported_files( $data, $imported_data );
    my $dict_search_struct = build_search_struct($data);

    for my $saveblock ( @{$data->{'save_blocks'}} ) {
        # check for non-existent categories
        if ( defined $saveblock->{'values'}{'_name.category_id'} ) {
            my $category_name = uc $saveblock->{'values'}{'_name.category_id'}[0];
            if ( uc get_definition_class( $saveblock ) eq 'HEAD' ) {
                if ( $category_name ne uc $data->{'values'}{'_dictionary.title'}[0] ) {
                    warn "$0: $filename save_$saveblock->{'name'}: WARNING, " .
                     "the value of the '_name.category_id' data item in the " .
                     "HEAD save frame must match the value of the " .
                     "'_dictionary.title' data item.\n";
                }
            } else {
                my $category_found = 0;
                foreach ( @{$data->{'save_blocks'}} ) {
                   if ( uc $_->{'name'} eq $category_name &&
                        uc $_->{'values'}{'_definition.scope'}[0] eq 'CATEGORY' ) {
                        $category_found = 1;
                        last;
                   }
                }

                if (!$category_found) {
                    warn "$0: $filename save_$saveblock->{'name'}: WARNING, " .
                         "the '$category_name' category could not be located.\n";
                }
            }
        }

        if ( !exists $saveblock->{'values'}{'_definition.scope'} ||
            lc $saveblock->{'values'}{'_definition.scope'}[0] eq 'item' ) {
            # check for alias that match the id
            if ( defined $saveblock->{'values'}{'_definition.id'} ) {
                my $definition_id = uc $saveblock->{'values'}{'_definition.id'}[0];
                for my $alias ( @{$saveblock->{'values'}{'_alias.definition_id'}} ) {
                    if ( $definition_id eq uc $alias ) {
                        warn "$0: $filename save_$saveblock->{'name'}: WARNING, " .
                             "the '_alias.definition_id' data item value '$alias' " .
                             "matches the '_definition.id' data item value -- " .
                             "the alias should be removed.\n";
                    }
                }
            }

            if ( defined $saveblock->{'values'}{'_enumeration.range'} ) {
                # TODO: implement proper content type retrieval logic
                my $type  = lc get_type_contents(
                    lc $saveblock->{'values'}{'_definition.id'}[0],
                    $saveblock,
                    $dict_search_struct
                );

                my $range = $saveblock->{'values'}{'_enumeration.range'}[0];
                my $item_range = parse_range($range);
                my $type_range = get_enum_range_from_type($type);

                if ( !is_subrange( $type_range, $item_range,
                                   { 'type' => 'numb' } ) ) {
                    warn "$0: $filename save_$saveblock->{'name'}: WARNING, " .
                         'the declared enumeration range ' .
                         range_to_string( $item_range, { 'type' => 'numb' } ) .
                         " violates the range imposed by the '$type' data type " .
                         range_to_string( $type_range, { 'type' => 'numb' } ) .
                         "\n";
                }

                if ( $report_redundant_range_limits ) {
                    if ( defined $item_range->[0] && defined $type_range->[0] &&
                         equals($item_range->[0], $type_range->[0], 5) ) {
                        warn "$0: $filename save_$saveblock->{'name'}: WARNING, " .
                             "the lower enumeration range limit '$item_range->[0]' " .
                             'is needlesly specified since the same lower limit ' .
                             "is imposed by the '$type' data type\n";
                    }

                    if ( defined $item_range->[1] && defined $type_range->[1] &&
                         equals($item_range->[1], $type_range->[1], 5) ) {
                        warn "$0: $filename save_$saveblock->{'name'}: WARNING, " .
                             "the upper enumeration range limit '$item_range->[1]' " .
                             'is needlesly specified since the same upper limit ' .
                             "is imposed by the '$type' data type\n";
                    }
                }
            }
        }

        foreach ( @{check_item_purpose($saveblock)} ) {
            warn "$0: $filename save_$saveblock->{'name'}: WARNING, $_\n";
        }


        my $type_purpose = lc get_type_purpose( $saveblock );
        if ( $type_purpose eq 'su' &&
             exists $saveblock->{'values'}{'_name.linked_item_id'} ) {
            my $linked_item_name = lc $saveblock->{'values'}{'_name.linked_item_id'}[0];
            my $linked_item;
            foreach ( @{$data->{'save_blocks'}} ) {
                if ( lc $_->{'values'}{'_definition.id'}[0] eq $linked_item_name ) {
                    $linked_item = $_;
                    last;
                }
            }
            if ( lc get_type_purpose($linked_item) ne 'measurand' ) {
                warn "$0: $filename save_$saveblock->{'name'}: WARNING, " .
                     'data item is defined as having the \'SU\' purpose, ' .
                     "however, it is linked to the $linked_item_name " .
                     "data item that has the " .
                     "'" . get_type_purpose($linked_item) . "' " .
                     'purpose and does not allow standard uncertainties' . "\n";
            }
        }

        if ( exists $saveblock->{'values'}{'_name.linked_item_id'} ) {
            if ( $type_purpose ne 'su' && $type_purpose ne 'link' ) {
                warn "$0: $filename save_$saveblock->{'name'}: WARNING, " .
                     'incorrect type purpose -- data item is defined as having ' .
                     "the '$type_purpose' type purpose while only \'SU\' and " .
                     "\'Link\' type purposes are allowed for data items that " .
                     'contain the _name.linked_item_id data item in their ' .
                     'definition' . "\n";
            }
        }
    }
}

##
# Checks if item definitions meet the requirements raised by the the declared
# item purpose.
#
# @param $save_block
#       Data item definition frame as returned by the COD::CIF::Parser.
# @return
#       Array reference to a list of validation messages.
##
sub check_item_purpose
{
    my ( $save_block ) = @_;

    my @validation_messages;

    my $type_purpose = lc get_type_purpose( $save_block );

    if ( $type_purpose eq 'link' &&
         !exists $save_block->{'values'}{'_name.linked_item_id'} ) {
        push @validation_messages,
             'incomplete data item definition -- data item is ' .
             'defined as having the \'Link\' purpose, but the ' .
             '_name.linked_item_id data item is not provided';
    }

    if ( $type_purpose eq 'su' &&
         !exists $save_block->{'values'}{'_name.linked_item_id'} ) {
        push @validation_messages,
             'incomplete data item definition -- data item is ' .
             'marked as defined the \'SU\' purpose, but the ' .
             '_name.linked_item_id data item is not provided';
    }

    if ( $type_purpose eq 'state' &&
         !exists $save_block->{'values'}{'_enumeration_set.state'} ) {
        push @validation_messages,
             'incomplete data item definition -- data item is ' .
             'defined as having the \'State\' purpose, but the ' .
             '_enumeration_set.state data item is not provided';
    }

    return \@validation_messages;
}

sub get_enum_range_from_type
{
    my ($type) = @_;

    $type = lc $type;
    my @range = (undef, undef);

    if ( $type eq 'count' ) {
        @range = (0, undef);
    } elsif ( $type eq 'index' ) {
        @range = (1, undef);
    }

    return \@range;
}

sub is_subrange
{
    my ($range, $subrange, $options) = @_;

    my $is_in_lower_range = !defined $subrange->[0] ||
        is_in_range( $subrange->[0], {
                        'range' => $range,
                        'type'  => $options->{'type'}
                    } );

    my $is_in_upper_range = !defined $subrange->[1] ||
        is_in_range( $subrange->[1], {
                        'range' => $range,
                        'type'  => $options->{'type'}
                    } );

    return $is_in_lower_range && $is_in_upper_range;
}

##
# Compares two floating point numbers using given decimal point precision.
# @param $float_1
#       First floating point number.
# @param $float_2
#       Second floating point number.
# @param $float_2
#       Decimal point digit precision.
# @return
#       1 if numbers are equal, 0 otherwise.
##
sub equals
{
    my ($float_1, $float_2, $dp) = @_;
    return ( ( sprintf "%.${dp}f", $float_1 ) eq
             ( sprintf "%.${dp}f", $float_2 ) ) ? 1 : 0;
}
