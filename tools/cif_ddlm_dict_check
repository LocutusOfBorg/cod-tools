#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#* Check DDLm dictionaries against a set of best practice rules.
#*
#* USAGE:
#*    $0 --options cif_core.dic
#**

use strict;
use warnings;
binmode STDOUT, ':encoding(UTF-8)';
binmode STDERR, ':encoding(UTF-8)';

use File::Basename;

use COD::CIF::Parser qw( parse_cif );
use COD::CIF::DDL::DDLm qw( get_imported_files
                            merge_imported_files );
use COD::SOptions qw( getOptions get_value );
use COD::SUsage qw( usage options );
use COD::ErrorHandler qw( process_warnings
                          process_parser_messages
                          report_message );
use COD::ToolsVersion;

my $use_parser = 'c';

my $die_on_errors   = 1;
my $die_on_warnings = 0;
my $die_on_notes    = 0;

#* OPTIONS:
#*
#*   --continue-on-errors
#*                     Do not terminate script if errors are raised (default).
#*   --die-on-errors
#*                     Terminate script immediately if errors are raised.
#*   --continue-on-warnings
#*                     Do not terminate script if warnings are raised (default).
#*   --die-on-warnings
#*                     Terminate script immediately if warnings are raised.
#*   --continue-on-notes
#*                     Do not terminate script if notes are raised (default).
#*   --die-on-notes
#*                     Terminate script immediately if notes are raised.
#*
#*   --help, --usage
#*                     Output a short usage message (this message) and exit.
#*   --version
#*                     Output version information and exit.
#**
@ARGV = getOptions(
    '--continue-on-errors'          => sub { $die_on_errors = 0 },
    '--die-on-errors'               => sub { $die_on_errors = 1 },

    '--continue-on-warnings' => sub { $die_on_warnings = 0 },
    '--die-on-warnings'      => sub { $die_on_warnings = 1 },

    '--continue-on-notes'    => sub { $die_on_notes = 0 },
    '--die-on-notes'         => sub { $die_on_notes = 1 },

    '--options'         => sub{ options; exit },
    '--help,--usage'    => sub{ usage; exit; },
    '--version'      => sub { print 'cod-tools version ',
                                 $COD::ToolsVersion::Version, "\n";
                                 exit }
);

my $die_on_error_level = {
    ERROR   => $die_on_errors,
    WARNING => $die_on_warnings,
    NOTE    => $die_on_notes
};

for my $filename ( @ARGV ) {
    my $options = { 'parser' => $use_parser, 'no_print' => 1 };
    my ( $data, $err_count, $messages ) = parse_cif( $filename, $options );
    process_parser_messages( $messages, $die_on_error_level );

    $data = $data->[0];
    my($filename, $dirs, $suffix) = fileparse($filename);
    my $imported_data = get_imported_files(
    {
        'container_file' => $data,
        # TODO: the path should also be constructed from the command line
        # arguments as well as a command line variable
        'file_path'      => [ './', $dirs ],
        'imported_files' => {},
        'parser_options' => $options
    }
    );
    $data = merge_imported_files( $data, $imported_data );

    for my $saveblock ( @{$data->{'save_blocks'}} ) {
        # check for non-existant categories
        if ( defined $saveblock->{'values'}{'_name.category_id'} ) {
            my $category_name = uc $saveblock->{'values'}{'_name.category_id'}[0];
            if ( defined $saveblock->{'values'}{'_definition.class'} &&
                 uc $saveblock->{'values'}{'_definition.class'}[0] eq 'HEAD' ) {
                if ( $category_name ne uc $data->{'values'}{'_dictionary.title'}[0] ) {
                    warn "$0: $filename save_$saveblock->{'name'}: WARNING, " .
                     "the value of the '_name.category_id' data item in the " .
                     "HEAD save frame must match the value of the " .
                     "'_dictionary.title' data item.\n";
                }
            } else {
                my $category_found = 0;
                foreach ( @{$data->{'save_blocks'}} ) {
                   if ( uc $_->{'name'} eq $category_name &&
                        uc $_->{'values'}{'_definition.scope'}[0] eq 'CATEGORY' ) {
                        $category_found = 1;
                        last;
                   }
                }

                if (!$category_found) {
                    warn "$0: $filename save_$saveblock->{'name'}: WARNING, " .
                         "the '$category_name' category could not be located.\n";
                }
            }
        }

        if ( !exists $saveblock->{'values'}{'_definition.scope'} ||
            lc $saveblock->{'values'}{'_definition.scope'}[0] eq 'item' ) {
            # check for alias that match the idea
            if ( defined $saveblock->{'values'}{'_definition.id'} ) {
                my $definition_id = uc $saveblock->{'values'}{'_definition.id'}[0];
                for my $alias ( @{$saveblock->{'values'}{'_alias.definition_id'}} ) {
                    if ( $definition_id eq uc $alias ) {
                        warn "$0: $filename save_$saveblock->{'name'}: WARNING, " .
                             "the '_alias.definition_id' data item value '$alias' " .
                             "matches the '_definition.id' data item value -- " .
                             "the alias should be removed.\n";
                    }
                }
            }

            if ( defined $saveblock->{'values'}{'_enumeration.range'} ) {
                my $type  = lc $saveblock->{'values'}{'_type.contents'}[0];
                my $range = $saveblock->{'values'}{'_enumeration.range'}[0];

                my $item_range = parse_range($range);
                my $type_range = get_enum_range_from_type($type);

                if ( !is_in_range($item_range->[0], $type_range) ||
                     !is_in_range($item_range->[1], $type_range) ) {
                    warn "$0: $filename save_$saveblock->{'name'}: WARNING, " .
                         'the declared enumeration range ' .
                         range_to_string($item_range) . ' violates the range ' .
                         "imposed by the '$type' data type " .
                         range_to_string($type_range) . "\n"
                }

                if ( defined $item_range->[0] && defined $type_range->[0] &&
                     equals($item_range->[0], $type_range->[0], 5) ) {
                    warn "$0: $filename save_$saveblock->{'name'}: WARNING, " .
                         "the lower enumeration range limit '$item_range->[0]' " .
                         'is needlesly specified since the same lower limit ' .
                         "is imposed by the '$type' data type\n";
                }

                if ( defined $item_range->[1] && defined $type_range->[1] &&
                     equals($item_range->[1], $type_range->[1], 5) ) {
                    warn "$0: $filename save_$saveblock->{'name'}: WARNING, " .
                         "the upper enumeration range limit '$item_range->[1]' " .
                         'is needlesly specified since the same upper limit ' .
                         "is imposed by the '$type' data type\n";
                }
            }
        }
    }
}

sub get_enum_range_from_type
{
    my ($type) = @_;

    $type = lc $type;
    my @range = (undef, undef);

    if ( $type eq 'count' ) {
        @range = (0, undef);
    } elsif ( $type eq 'index' ) {
        @range = (1, undef);
    }

    return \@range;
}

sub is_in_range
{
    my ($value, $range) = @_;

    if ( !defined $value ) {
        return 1
    };

    if ( defined $range->[0] && $value < $range->[0] ||
         defined $range->[1] && $value > $range->[1] ) {
        return 0;
    }

    return 1;
}

sub range_to_string
{
    my ($range) = @_;

    my $string;
    $string  = (defined $range->[0] ? "[$range->[0]" : '(-inf');
    $string .= ';';
    $string .= (defined $range->[1] ? "$range->[1]]" : '+inf)');

    return $string;
}

sub parse_range
{
    my ($range_string) = @_;

    $range_string =~ m/^([^:]+)?:([^:]+)?$/;
    my @range = ($1, $2);

    return \@range;
}

##
# Compares two floating point numbers using given decimal point precision.
# @param $float_1
#       First floating point number.
# @param $float_2
#       Second floating point number.
# @param $float_2
#       Decimal point digit precision.
# @return
#       1 if numbers are equal, 0 otherwise.
##
sub equals
{
    my ($float_1, $float_2, $dp) = @_;
    return ( ( sprintf "%.${dp}f", $float_1 ) eq
             ( sprintf "%.${dp}f", $float_2 ) ) ? 1 : 0;
}
