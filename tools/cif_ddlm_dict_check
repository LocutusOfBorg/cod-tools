#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#* Check DDLm dictionaries against a set of best practice rules.
#*
#* USAGE:
#*    $0 --options cif_core.dic
#**

use strict;
use warnings;
binmode STDOUT, ':encoding(UTF-8)';
binmode STDERR, ':encoding(UTF-8)';

use COD::CIF::Parser qw( parse_cif );
use COD::SOptions qw( getOptions get_value );
use COD::SUsage qw( usage options );
use COD::ErrorHandler qw( process_warnings
                          process_parser_messages
                          report_message );
use COD::ToolsVersion;

my $use_parser = 'c';

my $die_on_errors   = 1;
my $die_on_warnings = 0;
my $die_on_notes    = 0;

#* OPTIONS:
#*
#*   --continue-on-errors
#*                     Do not terminate script if errors are raised (default).
#*   --die-on-errors
#*                     Terminate script immediately if errors are raised.
#*   --continue-on-warnings
#*                     Do not terminate script if warnings are raised (default).
#*   --die-on-warnings
#*                     Terminate script immediately if warnings are raised.
#*   --continue-on-notes
#*                     Do not terminate script if notes are raised (default).
#*   --die-on-notes
#*                     Terminate script immediately if notes are raised.
#*
#*   --help, --usage
#*                     Output a short usage message (this message) and exit.
#*   --version
#*                     Output version information and exit.
#**
@ARGV = getOptions(
    '--continue-on-errors'          => sub { $die_on_errors = 0 },
    '--die-on-errors'               => sub { $die_on_errors = 1 },

    '--continue-on-warnings' => sub { $die_on_warnings = 0 },
    '--die-on-warnings'      => sub { $die_on_warnings = 1 },

    '--continue-on-notes'    => sub { $die_on_notes = 0 },
    '--die-on-notes'         => sub { $die_on_notes = 1 },

    '--options'         => sub{ options; exit },
    '--help,--usage'    => sub{ usage; exit; },
    '--version'      => sub { print 'cod-tools version ',
                                 $COD::ToolsVersion::Version, "\n";
                                 exit }
);

my $die_on_error_level = {
    ERROR   => $die_on_errors,
    WARNING => $die_on_warnings,
    NOTE    => $die_on_notes
};

for my $filename ( @ARGV ) {
    my $options = { 'parser' => $use_parser, 'no_print' => 1 };
    my ( $data, $err_count, $messages ) = parse_cif( $filename, $options );
    process_parser_messages( $messages, $die_on_error_level );

    for my $saveblock ( @{$data->[0]{'save_blocks'}} ) {
        # check for non-existant categories
        if ( defined $saveblock->{'values'}{'_name.category_id'} ) {
            my $category_name = uc $saveblock->{'values'}{'_name.category_id'}[0];
            if ( defined $saveblock->{'values'}{'_definition.class'} &&
                 uc $saveblock->{'values'}{'_definition.class'}[0] eq 'HEAD' ) {
                if ( $category_name ne uc $data->[0]{'values'}{'_dictionary.title'}[0] ) {
                    warn "$0: $filename save_$saveblock->{'name'}: WARNING, " .
                     "the value of the '_name.category_id' data item in the " .
                     "HEAD save frame must match the value of the " .
                     "'_dictionary.title' data item.\n";
                }
            } else {
                my $category_found = 0;
                foreach ( @{$data->[0]{'save_blocks'}} ) {
                   if ( uc $_->{'name'} eq $category_name &&
                        uc $_->{'values'}{'_definition.scope'}[0] eq 'CATEGORY' ) {
                        $category_found = 1;
                        last;
                   }
                }

                if (!$category_found) {
                    warn "$0: $filename save_$saveblock->{'name'}: WARNING, " .
                         "the '$category_name' category could not be located.\n";
                }
            }
        }

        if ( !exists $saveblock->{'values'}{'_definition.scope'} ||
            lc $saveblock->{'values'}{'_definition.scope'}[0] eq 'item' ) {
            # check for alias that match the idea
            if ( defined $saveblock->{'values'}{'_definition.id'} ) {
                my $definition_id = uc $saveblock->{'values'}{'_definition.id'}[0];
                for my $alias ( @{$saveblock->{'values'}{'_alias.definition_id'}} ) {
                    if ( $definition_id eq uc $alias ) {
                        warn "$0: $filename save_$saveblock->{'name'}: WARNING, " .
                             "the '_alias.definition_id' data item value '$alias' " .
                             "matches the '_definition.id' data item value -- " .
                             "the alias should be removed.\n";
                    }
                }
            }
        }
    }
}
