#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#* Check DDLm dictionaries against a set of best practice rules.
#*
#* USAGE:
#*    $0 --options cif_core.dic
#**

use strict;
use warnings;
binmode STDOUT, ':encoding(UTF-8)';
binmode STDERR, ':encoding(UTF-8)';

use File::Basename;

use COD::CIF::Parser qw( parse_cif );
use COD::CIF::DDL::DDLm qw( build_search_struct
                            get_imported_files
                            merge_imported_files
                            get_type_contents
                            get_type_purpose
                            get_definition_class
                            get_definition_scope
                            get_data_alias );
use COD::CIF::DDL::Ranges qw( parse_range
                              range_to_string
                              is_in_range );
use COD::SOptions qw( getOptions get_value );
use COD::SUsage qw( usage options );
use COD::ErrorHandler qw( process_warnings
                          process_parser_messages
                          report_message );
use COD::ToolsVersion;

my $use_parser = 'c';
my $report_redundant_range_limits = 0;
my $check_references_in_descriptions = 0;

#* OPTIONS:
#*
#*   --report-redundant-range-limits
#*                     Report explicit range limits that match implicit
#*                     range limits imposed by the content type.
#*   --no-report-redundant-range-limits
#*                     Do not report explicit range limits that match implicit
#*                     range limits imposed by the content type (default).
#*
#*   --check-references-in-descriptions
#*                     Check if the data names referenced in the free-text
#*                     descriptions of other data items are defined in the
#*                     dictionary. This check use ad hoc code to recognise
#*                     data names and thus might produce false-negatives.
#*   --no-check-references-in-descriptions
#*                     Do not check if the data names referenced in the
#*                     free-text descriptions of other data items are defined
#*                     in the dictionary (default).
#*
#*   --help, --usage
#*                     Output a short usage message (this message) and exit.
#*   --version
#*                     Output version information and exit.
#**
@ARGV = getOptions(
    '--report-redundant-range-limits'    =>
            sub { $report_redundant_range_limits = 1 },
    '--no-report-redundant-range-limits' =>
            sub { $report_redundant_range_limits = 0 },

    '--check-references-in-descriptions' =>
            sub { $check_references_in_descriptions = 1 },
    '--no-check-references-in-descriptions' =>
            sub { $check_references_in_descriptions = 0 },

    '--options'         => sub{ options; exit },
    '--help,--usage'    => sub{ usage; exit },
    '--version'      => sub { print 'cod-tools version ',
                                 $COD::ToolsVersion::Version, "\n";
                                 exit }
);

my $die_on_error_level = {
    'ERROR'   => 1,
    'WARNING' => 0,
    'NOTE'    => 0
};

for my $filename ( @ARGV ) {
    my $options = { 'parser' => $use_parser, 'no_print' => 1 };
    my ( $data, $err_count, $messages ) = parse_cif( $filename, $options );
    process_parser_messages( $messages, $die_on_error_level );

    $data = $data->[0];
    my($filename, $dirs, $suffix) = fileparse($filename);
    my $imported_data = get_imported_files(
    {
        'container_file' => $data,
        # TODO: the path should also be constructed from the command line
        # arguments as well as a command line variable
        'file_path'      => [ './', $dirs ],
        'imported_files' => {},
        'parser_options' => $options
    }
    );
    $data = merge_imported_files( $data, $imported_data );
    my $dict_search_struct = build_search_struct($data);

    foreach ( @{check_head_category($data)} ) {
        print "$0: $filename: $_.\n";
    }

    for my $saveblock ( @{$data->{'save_blocks'}} ) {
        my @warnings;

        if ( $check_references_in_descriptions ) {
            push @warnings, @{ check_references_in_descriptions(
                                    $saveblock,
                                    $dict_search_struct
                               ) };
        }

        push @warnings, @{check_category_presence($saveblock, $data)};
        if ( lc get_definition_scope($saveblock) eq 'item' ) {
            push @warnings, @{ check_aliases($saveblock) };
            push @warnings, @{ check_enumeration_range(
                                $saveblock,
                                $dict_search_struct,
                                { 'report_redundant_range_limits' =>
                                    $report_redundant_range_limits } ) };
        };
        push @warnings, @{check_item_purpose($saveblock)};
        push @warnings, @{check_linked_items($saveblock, $data)};

        foreach ( @warnings ) {
            print "$0: $filename save_$saveblock->{'name'}: WARNING, $_.\n";
        }
    }
}

sub check_head_category
{
    my ( $data_frame ) = @_;

    my @validation_messages;

    my @head_categories;
    for my $save_frame ( @{$data_frame->{'save_blocks'}} ) {
        if ( uc get_definition_class( $save_frame ) eq 'HEAD' ) {
            push @head_categories, $save_frame;
        }
    };

    if ( !@head_categories ) {
        push @validation_messages,
             'the mandatory HEAD save frame is missing';
    };

    if ( @head_categories > 1 ) {
        push @validation_messages,
             'more than one HEAD save frame located -- save frames [' .
             ( join ', ', map { "'$_->{'name'}'" } @head_categories ) .
             '] are marked as having the \'HEAD\' definition class';
    };

    return \@validation_messages;
}

sub check_category_presence
{
    my ($save_frame, $data) = @_;

    my @validation_messages;

    # check for non-existent categories
    if ( defined $save_frame->{'values'}{'_name.category_id'} ) {
        my $category_name = uc $save_frame->{'values'}{'_name.category_id'}[0];
        if ( uc get_definition_class( $save_frame ) eq 'HEAD' ) {
            if ( $category_name ne uc $data->{'values'}{'_dictionary.title'}[0] ) {
                push @validation_messages,
                     'the value of the \'_name.category_id\' data ' .
                     'item in the \'HEAD\' save frame must match the value ' .
                     'of the \'_dictionary.title\' data item';
            }
        } else {
            my $category_found = 0;
            foreach ( @{$data->{'save_blocks'}} ) {
               if ( uc $_->{'name'} eq $category_name &&
                    uc get_definition_scope($_) eq 'CATEGORY' ) {
                    $category_found = 1;
                    last;
               }
            }

            if (!$category_found) {
                push @validation_messages,
                     "the '$category_name' category could not be located";
            }
        }
    }

    return \@validation_messages;
}

sub check_aliases
{
    my ( $save_frame ) = @_;

    return [] if !defined $save_frame->{'values'}{'_definition.id'};

    my @validation_messages;

    my $definition_id = uc $save_frame->{'values'}{'_definition.id'}[0];
    for my $alias ( @{get_data_alias($save_frame)} ) {
        if ( $definition_id eq uc $alias ) {
            push @validation_messages,
                 'the \'_alias.definition_id\' data item value ' .
                 "'$alias' matches the '_definition.id' data item value -- " .
                 'the alias should be removed';
        }
    }

    return \@validation_messages;
}

sub check_enumeration_range
{
    my ($save_frame, $dict_struct, $options) = @_;

    return [] if !defined $save_frame->{'values'}{'_enumeration.range'};

    $options = {} if !defined $options;

    my @validation_messages;

    my $type  = lc get_type_contents(
        lc $save_frame->{'values'}{'_definition.id'}[0],
        $save_frame,
        $dict_struct
    );

    my $range = $save_frame->{'values'}{'_enumeration.range'}[0];
    my $item_range = parse_range($range);
    my $type_range = get_enum_range_from_type($type);
    if ( !is_subrange( $type_range, $item_range,
                       { 'type' => 'numb' } ) ) {
        push @validation_messages,
             'the declared enumeration range ' .
             range_to_string( $item_range, { 'type' => 'numb' } ) .
             " violates the range imposed by the '$type' data type " .
             range_to_string( $type_range, { 'type' => 'numb' } );
    }

    if ( $options->{'report_redundant_range_limits'} ) {
        if ( defined $item_range->[0] && defined $type_range->[0] &&
             equals($item_range->[0], $type_range->[0], 5) ) {
           push @validation_messages,
                "the lower enumeration range limit '$item_range->[0]' " .
                'is needlesly specified since the same lower limit ' .
                "is imposed by the '$type' data type";
        }

        if ( defined $item_range->[1] && defined $type_range->[1] &&
             equals($item_range->[1], $type_range->[1], 5) ) {
           push @validation_messages,
                "the upper enumeration range limit '$item_range->[1]' " .
                'is needlesly specified since the same upper limit ' .
                "is imposed by the '$type' data type";
        }
    }

    return \@validation_messages;
}

sub check_linked_items
{
    my ($save_frame, $data) = @_;

    return [] if !exists $save_frame->{'values'}{'_name.linked_item_id'};

    my @validation_messages;

    my $type_purpose = lc get_type_purpose( $save_frame );
    if ( $type_purpose eq 'su' ) {
        my $linked_item_name = lc $save_frame->{'values'}{'_name.linked_item_id'}[0];
        my $linked_item;
        foreach ( @{$data->{'save_blocks'}} ) {
            if ( lc $_->{'values'}{'_definition.id'}[0] eq $linked_item_name ) {
                $linked_item = $_;
                last;
            }
        }
        if ( lc get_type_purpose($linked_item) ne 'measurand' ) {
            push @validation_messages,
                 'data item is defined as having the \'SU\' purpose, ' .
                 "however, it is linked to the $linked_item_name " .
                 'data item that has the ' .
                 '\'' . get_type_purpose($linked_item) . '\' ' .
                 'purpose and does not allow standard uncertainties';
        }
    }

    if ( $type_purpose ne 'su' && $type_purpose ne 'link' ) {
        push @validation_messages,
             'incorrect type purpose -- data item is defined as having ' .
             "the '$type_purpose' type purpose while only " .
             '\'SU\' and \'Link\' type purposes are allowed for data ' .
             'items that contain the _name.linked_item_id data item in ' .
             'their definition';
    }

    return \@validation_messages;
}

##
# Checks if the data names used in the free-text description of the data
# item are defined in the dictionary. This subroutine treats all string
# that contain underscores as data item/category names thus false warnings
# might be produced.
#
# @param $save_block
#       Data item definition frame as returned by the COD::CIF::Parser.
# @param $dict_search_struct
#       Dictionary search structure as returned by the
#       COD::CIF::DDL::DDLm::build_search_struct subroutine.
# @return
#       Array reference to a list of validation messages.
##
sub check_references_in_descriptions
{
    my ( $save_block, $dict_search_struct ) = @_;

    my @validation_messages;

    if ( exists $save_block->{'values'}{'_description.text'} ) {
        my $description = $save_block->{'values'}{'_description.text'}[0];
        while ( $description =~ m/([^ ]*_[^ ]*)/g ) {
            my $referenced_tag = $1;
            $referenced_tag =~ s/^[(']//;
            $referenced_tag =~ s/[\n.),']*$//;
            $referenced_tag = lc $referenced_tag;

            if ( $referenced_tag =~ m/^_/ ) {
                if (!exists $dict_search_struct->{'Item'}{$referenced_tag} ) {
                    push @validation_messages,
                         'WARNING, the save frame description seems to be ' .
                         "referencing the '$referenced_tag' data item " .
                         'which is not defined in the dictionary';
                }
            } else {
                if (!exists $dict_search_struct->{'Category'}{$referenced_tag} ) {
                    push @validation_messages,
                         'WARNING, the save frame description seems to be ' .
                         "referencing the '$referenced_tag' category " .
                         'which is not defined in the dictionary';
                }
            }
        }
    }

    return \@validation_messages;
}

##
# Checks if item definitions meet the requirements raised by the the declared
# item purpose.
#
# @param $save_block
#       Data item definition frame as returned by the COD::CIF::Parser.
# @return
#       Array reference to a list of validation messages.
##
sub check_item_purpose
{
    my ( $save_block ) = @_;

    my @validation_messages;

    my $type_purpose = lc get_type_purpose( $save_block );

    if ( $type_purpose eq 'link' &&
         !exists $save_block->{'values'}{'_name.linked_item_id'} ) {
        push @validation_messages,
             'incomplete data item definition -- data item is ' .
             'defined as having the \'Link\' purpose, but the ' .
             '_name.linked_item_id data item is not provided';
    }

    if ( $type_purpose eq 'su' &&
         !exists $save_block->{'values'}{'_name.linked_item_id'} ) {
        push @validation_messages,
             'incomplete data item definition -- data item is ' .
             'marked as defined the \'SU\' purpose, but the ' .
             '_name.linked_item_id data item is not provided';
    }

    if ( $type_purpose eq 'state' &&
         !exists $save_block->{'values'}{'_enumeration_set.state'} ) {
        push @validation_messages,
             'incomplete data item definition -- data item is ' .
             'defined as having the \'State\' purpose, but the ' .
             '_enumeration_set.state data item is not provided';
    }

    return \@validation_messages;
}

sub get_enum_range_from_type
{
    my ($type) = @_;

    $type = lc $type;
    my @range = (undef, undef);

    if ( $type eq 'count' ) {
        @range = (0, undef);
    } elsif ( $type eq 'index' ) {
        @range = (1, undef);
    }

    return \@range;
}

sub is_subrange
{
    my ($range, $subrange, $options) = @_;

    my $is_in_lower_range = !defined $subrange->[0] ||
        is_in_range( $subrange->[0], {
                        'range' => $range,
                        'type'  => $options->{'type'}
                    } );

    my $is_in_upper_range = !defined $subrange->[1] ||
        is_in_range( $subrange->[1], {
                        'range' => $range,
                        'type'  => $options->{'type'}
                    } );

    return $is_in_lower_range && $is_in_upper_range;
}

##
# Compares two floating point numbers using given decimal point precision.
# @param $float_1
#       First floating point number.
# @param $float_2
#       Second floating point number.
# @param $float_2
#       Decimal point digit precision.
# @return
#       1 if numbers are equal, 0 otherwise.
##
sub equals
{
    my ($float_1, $float_2, $dp) = @_;
    return ( ( sprintf "%.${dp}f", $float_1 ) eq
             ( sprintf "%.${dp}f", $float_2 ) ) ? 1 : 0;
}
